{"./":{"url":"./","title":"本书简介","keywords":"","body":"本书简介 "},"page/1010.html":{"url":"page/1010.html","title":"数据结构","keywords":"","body":"数据结构 "},"page/1011.html":{"url":"page/1011.html","title":"逻辑结构","keywords":"","body":"逻辑结构 "},"page/1012.html":{"url":"page/1012.html","title":"线性结构","keywords":"","body":"线性结构 "},"page/1013.html":{"url":"page/1013.html","title":"线性表","keywords":"","body":"线性表 "},"page/1014.html":{"url":"page/1014.html","title":"定义","keywords":"","body":"定义 "},"page/1015.html":{"url":"page/1015.html","title":"特殊","keywords":"","body":"特殊 "},"page/1016.html":{"url":"page/1016.html","title":"有序表","keywords":"","body":"有序表 "},"page/1017.html":{"url":"page/1017.html","title":"栈","keywords":"","body":"栈 "},"page/1018.html":{"url":"page/1018.html","title":"队列","keywords":"","body":"队列 "},"page/1019.html":{"url":"page/1019.html","title":"串","keywords":"","body":"串 "},"page/1020.html":{"url":"page/1020.html","title":"数组","keywords":"","body":"数组 "},"page/1021.html":{"url":"page/1021.html","title":"广义表","keywords":"","body":"广义表 "},"page/1022.html":{"url":"page/1022.html","title":"非线性结构","keywords":"","body":"非线性结构 "},"page/1023.html":{"url":"page/1023.html","title":"树型结构","keywords":"","body":"树型结构 "},"page/1024.html":{"url":"page/1024.html","title":"树","keywords":"","body":"树 "},"page/1025.html":{"url":"page/1025.html","title":"森林","keywords":"","body":"森林 "},"page/1026.html":{"url":"page/1026.html","title":"二叉树","keywords":"","body":"二叉树 "},"page/1027.html":{"url":"page/1027.html","title":"哈夫曼树","keywords":"","body":"哈夫曼树 "},"page/1028.html":{"url":"page/1028.html","title":"图状结构","keywords":"","body":"图状结构 "},"page/1029.html":{"url":"page/1029.html","title":"集合结构","keywords":"","body":"集合结构 "},"page/1030.html":{"url":"page/1030.html","title":"存储结构","keywords":"","body":"存储结构 "},"page/1031.html":{"url":"page/1031.html","title":"顺序","keywords":"","body":"顺序 "},"page/1032.html":{"url":"page/1032.html","title":"链接","keywords":"","body":"链接 "},"page/1033.html":{"url":"page/1033.html","title":"索引","keywords":"","body":"索引 "},"page/1034.html":{"url":"page/1034.html","title":"散列","keywords":"","body":"散列 "},"page/1035.html":{"url":"page/1035.html","title":"关系","keywords":"","body":"关系 算法与数据结构既有联系又有区别。 联系：数据结构是算法设计的基础。算法的操作对象是数据结构，在设计算法时，通常要构建适合这种算法的数据结构。数据结构设计主要是选择数据的存储方式，如确定求解问题中的数据采用数组存储还是采用链表存储等。算法设计就是在选定的存储结构上设计一个满足要求的好算法。 区别：数据结构关注的是数据的逻辑结构、存储结构以及基本操作，而算法更多的是关注如何在数据结构的基础上解决实际问题。算法是编程思想，数据结构则是这些思想的逻辑基础。 "},"page/1036.html":{"url":"page/1036.html","title":"算法","keywords":"","body":"算法 概述 ​ 算法被公认为是计算机科学的基石,算法理论研究的是算法的设计技术和分析技术。 ​ 前者回答的是“对特定的问题,如何提出一个算法来求解?”这样的问题,即如何设计一个有效的算法解决特定的问题; ​ 后者回答的是“该算法是否足够好? ”,即对已设计的算法如何评价或判断其优劣,或者对求解同一个问题的多个算法如何进行比较和评价。 ​ 二者是互相依存的,设计出的算法需要检验和评价,对算法的分析反过来又可以帮助改进算法的设计。 　　算法是求解问题的一系列计算步骤，用来将输入数据转换成输出结果 ： 输入-->算法-->输出 　　如果一个算法对其每一个输入实例，都能输出正确的结果并停止，则称它是正确的。 ​ 算法( Algorithm )是对特定问题求解步骤的一种描述,它是指令的有限序列,其中每一条指令表示一个或多个操作。 重要特性 (1) 有穷性 一个算法必须总是(对任何合法的输入值)在执行有穷步之后结束,且每一步都可在有穷时间内完成。 对于任意一组合法输入值，在执行有穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。 算法与程序区别：程序没有有穷性 (2) 确定性 算法中的每一条指令必须有确切的含义,理解时不会产生二义性。并且在任何条件下,算法只有唯一的一条执行路径,即对于相同的输入只能得出相同的输出。 对于每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。 (3) 可行性 一个算法是可行的,即算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。 算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。 (4) 输入性 一个算法有零个或多个输入,这些输入取自于某个特定的对象的集合。 作为算法加工对象的量值，通常体现为算法中的一组变量。有些输入量需要在算法执行过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。 (5) 输出性 一个算法有一个或多个输出,这些输出是同输入有着某些特定关系的。 它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法的功能。 算法表示 常用的表示算法的方法有自然语言、流程图、程序设计语言和伪代码等。 (1) 自然语言 其最大的优点是容易理解,缺点是容易出现二义性,并且算法通常很冗长。 (2) 流程图 其优点是直观易懂,缺点是严密性不如程序设计语言,灵活性不如自然语言。 (3) 程序设计语言 其优点是能用计算机直接执行,缺点是抽象性差,使算法设计者拘泥于描述算法的具体细节,忽略了 “好”算法和正确逻辑的重要性。此外,还要求算法设计者掌握程序设计语言及编程技巧。 (4) 伪代码 伪代码是介于自然语言和程序设计语言之间的方法,它釆用某一程序设计语言的基本语法,同时结合自然语言来表达。计算机科学家从来没有对伪代码的书写形式达成过共识。在伪代码中,可以采用最具表达力的、最简明扼要的方法来表达一个给定的算法。 "},"page/1042.html":{"url":"page/1042.html","title":"算法分析","keywords":"","body":"算法分析 通常,求解一个问题可能会有多种算法可以选择,选择的主要标准首先是算法的正确性、可靠性、简单性和易理解性,其次是算法的时间复杂度和空间复杂度要低,这是算法分析技术的主要内容。 算法分析，算法分析是分析算法占用计算机资源的情况。所以算法分析的两个主要方面是分析算法的时间复杂度和空间复杂度。 从基本概念上看,算法分析是指对一个算法所需要的资源进行估算,这些资源包括内存、通信带宽、计算机硬件和时间等,所需要的资源越多,该算法的复杂度就越高。不言而喻,对于任何给定的问题,设计出复杂度尽可能低的算法是设计算法时追求的重要目标。另一方面,当给定问题有很多种算法时,选择其中复杂度最低者是一个重要准则。因此,算法的复杂度分析对算法的设计和选择有重要的指导意义和实用价值。 而在计算机资源中,最重要的是时间和空间(存储器)资源,因此复杂度分析主要包括时间复杂度和空间复杂度分析。 程序好坏决定因素 算法选用的策略 问题的规模 编写程序的语言 编译程序产生的机器代码的质量 计算机执行指令的速度 "},"page/1043.html":{"url":"page/1043.html","title":"时间复杂度","keywords":"","body":"时间复杂度（问题的规模） 概述 　　一个特定算法的“运行工作量”的大小，只依赖于问题的规模（通常用整数量n表示），或者说，它是问题规模的函数。 　　假如，随着问题规模 n 的增长，算法执行时间的增长率和 f(n) 的增长率相同，则可记作：T (n) = O(f(n)), 称T (n) 为算法的(渐近)时间复杂度。 　　一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）构成的，算法的运行时间取决于两者的综合效果。 ​ 由于时间复杂度与空间复杂度分别对算法占用的时间和空间资源进行分析,计算方法相似,且空间复杂度分析相对简单一些,因此下面主要讨论时间复杂度。算法的时间复杂度分析主要是分析算法的运行时间,即算法执行所需要的基本操作数。 一般步骤 分析算法时间复杂度的一般步骤 　　从算法中选取一种对于所研究的问题来说是基本操作的原操作，以该基本操作 在算法中重复执行的次数 作为算法运行时间的衡量准则。 　　“基本操作” 指的是，该操作重复执行次数和算法的运行时间成正比。 　　算法的执行时间=∑原操作(i)的执行次数×原操作(i)的执行时间 　　详细算法的执行时间与原操作执行次数之和成正比 　　算法= 控制结构+ 原操作（固有数据类型的操作） 复杂度情况 不同规模的输入所需要的基本操作数是不相同的,例如用同一个排序算法排序100个数和排序10 000个数所需要的基本操作数是不相同的,因此考虑特定输入规模的算法的具体操作数既是不现实的也是不必要的。在算法分析中,可以建立以输入规模n为自变量的函数$T(n)$来表示算法的时间复杂度。 即使对于相同的输入规模,数据分布不相同也影响了算法执行路径的不同,因此所需要的执行时间也不同。根据不同的输入,将算法的时间复杂度分析分为3种情况。 (1) 最佳情况 使算法执行时间最少的输入。一般情况下,不进行算法在最佳情况下的时间复杂度分析。应用最佳情况分析的一个例子是已经证明基于比较的排序算法的时间复杂度下限为 $\\Omega (nlgn)$那么就不需要白费力气去想方设法将该类算法改进为线性时间复杂度的算法。 (2) 最坏情况 使算法执行时间最多的输入。一般会进行算法在最坏时间复杂度的分析,因为最坏情况是在任何输入下运行时间的一个上限,它给我们提供一个保障,实际情况不会比这更糟糕。另外,对于某些算法来说,最坏情况还是相当频繁的。而且对于许多算法来说,平均情况通常与最坏情况下的时间复杂度一样。 (3) 平均情况 算法的平均运行时间,一般来说,这种情况很难分析。举个简单的例子,现要排序10个不同的整数,输入就有10!种不同的情况,平均情况的时间复杂度要考虑每一种输入及其该输入的概率。平均情况分析可以按以下3个步骤进行。 1 将所有的输入按其执行时间分类。 2 确定每类输入发生的概率。 3 确定每类输入的执行时间。 下式给出了 一般算法在平均情况下的复杂度分析。 T(n)=∑i=1mpi×ti T(n)= \\sum_{i=1}^{m}p_i \\times t_i T(n)=​i=1​∑​m​​p​i​​×t​i​​ ​ 其中,仍$p_i$表示第i类输入发生的概率; $t_i$表示第i类输入的执行时间,输入分为m类。 　　设一个算法的输入规模为n，Dn是所有输入的集合，任一输入I∈Dn，P(I)是I出现的概率，有ΣP(I) =1，T(I)是算法在输入I下所执行的基本语句次数，则该算法的平均执行时间为：A(n)=$\\sum_{I\\in D_n}P(I)*T(I)$。　　 　　也就是说算法的平均情况是指用各种特定输入下的基本语句执行次数的带权平均值。 　　算法的最好情况为：G(n)=$MIN_{I\\in D_n}{T(I)}$，是指算法在所有输入I下所执行基本语句的最少次数。 　　算法的最坏情况为：W(n)=$MAX_{I\\in D_n}{T(I)}$，是指算法在所有输入I下所执行基本语句的最大次数。 渐进符号 以输入规模n为自变量建立的时间复杂度实际上还是较复杂的,例如$an^2+bn+c$ ,不仅与输入规模有关,还与系数a、b、和c 有关。此时可以对该函数做进一步的抽象,仅考虑运行时间的增长率或称为增长的量级,如忽略上式中的低阶项和髙阶项的系数,仅考虑$n^2$。当输入规模大到只有与运行时间的增长量级有关时,就是在研究算法的渐进效率。也就是说,从极限角度看,只关心算法运行时间如何随着输入规模的无限增长而增长。下面简单介绍3种常用的标准方法来简化算法的渐进分析。 (1) $O$记号 定义为: 给定一个函数$g(n)$,$O(g(n))$={f(n): 存在正常数c和$n_0$,使得对所有的$n \\ge n_0$,有$0 \\le f(n) \\le cg(n)}$ 如图下图 ( a )所示。$O( g ( n ))$表示一个函数集合,往往用该记号给出一个算法运行时间的渐进上界。 　（大O符号），f(n)=O(g(n))（读作“f(n)是g(n)的大O”）当且仅当存在正常量c和n0，使当n≥n0时，f(n)≤cg(n)，即g(n)为f(n)的上界。 　如3n+2=O(n)，因为当n≥2时，3n+2≤4n。 　10n^2+4n+2=O(n^4)，因为当n≥2时，10n^2+4n+2≤10n^4。 　　大O符号用来描述增长率的上界，表示f(n)的增长最多像g(n) 增长的那样快，也就是说，当输入规模为n时，算法消耗时间的最大值。这个上界的阶越低，结果就越有价值，所以，对于$10n^2+4n+2$，O(n^2^)比O(n^4^) 有价值。 　　一个算法的时间用大O符号表示时，总是采用最有价值的g(n)表示，称之为“紧凑上界”或“紧确上界”。 　　一般地，如果$f(n)=amn^m+a{m-1}n^{m-1}+...+a_1n+a_0$有$f(n)= O(n^m)$ 在难以精确计算基本操作执行次数（或语句频度）的情况下，只需求出它关于n的增长率或阶即可2.一个算法的时间复杂度可以具体分为最好、最差（又称最坏）和平均三种情况讨论。 除特别说明外，正常均指最坏情况下的时间复杂度。 $O(log_2n) (2) $\\Omega$记号 定义为: 给定一个函数$g(n)$,$\\Omega(g(n))$={f(n): 存在正常数c和$n_0$,使得对所有的$n \\ge n_0$,有$0 \\le cg(n) \\le f(n)}$ 如图下图 ( b )所示。$\\Omega( g ( n ))$表示一个函数集合,往往用该记号给出一个算法运行时间的渐进下界。 （大Ω符号），f(n)= Ω(g(n))（读作“f(n)是g(n)的大Ω”）当且仅当存在正常量c和nθ，使当n≥n0时，f(n)≥cg(n)，即g(n)为f(n)的下界。 　　如3n+2=Ω(n)，因为当n≥1时，3n+2≥3n。 　　10n2+4n+2=Ω(n2)，因为当n≥1时，10n2+4n+2≥n2。　　 　　大Ω符号用来描述增长率的下界，表示f(n)的增长最少像g(n) 增长的那样快，也就是说，当输入规模为n时，算法消耗时间的最小值。 与大O符号对称，这个下界的阶越高，结果就越有价值，所以，对于10n2+4n+2，Ω(n2)比Ω(n) 有价值。一个算法的时间用大Ω符号表示时，总是采用最有价值的g(n)表示，称之为“紧凑下界”或“紧确下界”。 　　一般地，如果$f(n)=amn^m+a{m-1}n^{m-1}+...+a_1n+a_0$有$f(n)= \\Omega(n^m)$ (3) $\\Theta$记号 定义为: 给定一个函数$g(n)$,$\\Theta(g(n))$={f(n): 存在正常数$c_1$、$c_2$和$n_0$,使得对所有的$n \\ge n_0$,有$0 \\le c_1g(n) \\le f(n)}$ 如图下图 ( a )所示。$\\Theta( g ( n ))$表示一个函数集合,往往用该记号给出一个算法运行时间的渐进上界和渐进下届，即渐进紧致界。 （大Θ符号），f(n)= Θ(g(n))（读作“f(n)是g(n)的大Θ”）当且仅当存在正常量c1、c2和n0，使当n≥n0时，有c1g(n)≤f(n)≤c2g(n)，即g(n)与f(n)的同阶。 　　如3n+2=Θ (n)，10n2+4n+2=Θ(n2)。 　　一般地，如果，有f(n)=Θ(nm)。 　　大Θ符号比大O符号和大Ω符号都精确，f(n)=Θ(g(n)，当且仅当g(n)既是f(n)的上界又是f(n)的下界。 记号的用例图 由上述定义可知，$f(n)=\\Theta(g(n))$当且仅当$f(n)=O(g(n))$和$f(n)=\\Omega(g(n))$ 算法选用的策略 非递归算法的时间复杂度分析 　　对于非递归算法，分析其时间复杂度相对比较简单，关键是求出代表算法执行时间的表达式。 　　通常是算法中基本语句的执行次数，是一个关于问题规模n的表达式，然后用渐进符号来表示这个表达式即得到算法的时间复杂度。 两个矩阵相乘 void mult(inta[], int b[], int&c[] ) { // 以二维数组存储矩阵元素，c为 a 和 b的乘积 for (i=1; i 选择排序 //将a中整数序列重新排序成自小到大有序的整数序列 void select_sort(int& a[],int n){ for(i=0; ia[i] } } } }//时间复杂度O(n^2) 冒泡排序 //将a中整数序列重新排序成自小到大有序的整数序列 void bubble_sort(int& a[],int n){ for(i=n-1,change=TRUE; i>1 &&change; --i){ change = FALSE; //change为元素进行交换标志 for(j=0; ja[j+1]){ a[j]a[j+1]; //基本操作：赋值操作 change = TRUE; } }//一趟起泡 } }//时间复杂度O(n^2) 给出以下算法的时间复杂度。 void func(int n) { int i=1,k=100; while (i 递归算法的时间复杂度分析 　　递归算法是采用一种分而治之的方法，把一个“大问题”分解为若干个相似的“小问题”来求解。 　　对递归算法时间复杂度的分析，关键是根据递归过程建立递推关系式，然后求解这个递推关系式，得到一个表示算法执行时间的表达式，最后用渐进符号来表示这个表达式即得到算法的时间复杂度。 有如下递归函数fact(n)，分析其时间复杂度 int fact(int n){ if(n 有以下递归算法： void mergesort(int a[],int i,int j) { int m; if (i!=j) { m=(i+j)/2; mergesort(a,i,m); mergesort(a,m+1,j); merge(a,i,j,m); } } 其中，mergesort()用于数组a[0..n-1]（设n=2k，这里的k为正整数）的归并排序，　　调用该算法的方式为： mergesort(a，0，n-1)； 另外merge(a，i，j，m)用于两个有序子序列a[i..j]和a[j+1..m]的有序合并，　　是非递归函数，它的时间复杂度为O(n)（这里n=j-i+1）。分析上述调用的时间复杂度。 解：设调用mergesort(a，0，n-1)的执行时间为T(n)，由其执行过程得到以下求执行时间的递归关系（递推关系式）： T(n)=O(1) 当n=1 T(n)=2T(n/2)+O(n) 当n>1 其中，O(n)为merge()所需的时间，设为cn（c为正常量）。因此： T(n) = 2T(n/2)+cn=2[2T(n/22)+cn/2]+cn=22T(n/22)+2cn = 23T(n/23)+3cn = … = 2kT(n/2k)+kcn = nO(1)+cnlog2n=n+cnlog2n //这里假设n=2k，则k=log2n = O(nlog2n) 求解梵塔问题的递归算法如下，分析其时间复杂度。 void Hanoi(int n,char x,char y,char z) { if (n==1) printf(\"将盘片%d从%c搬到%c\\n\",n,x,z); else { Hanoi(n-1,x,z,y); printf(\"将盘片%d从%c搬到%c\\n\",n,x,z); Hanoi(n-1,y,x,z); } } 设调用Hanoi(n，x，y，z)的执行时间为T(n)，由其执行过程得到以下求执行时间的递归关系（递推关系式）： T(n)=O(1) 当n=1 T(n)=2T(n-1)+1 当n>1 T(n) = 2[2T(n-2)+1]+1+1 = 2*2T(n-2)+1+2*1 = 2^2*T(n-2)+1+2*1 //T(n-2)=2(T(n-3))+1 = 2^2*(2(T(n-3))+1)+1+2*1 = 2^2*(2(T(n-3))+1)+1+2*1 = 2^3*T(n-3)+2*2+1+2*1 //第二次 = 2^2*T(n-2) + 1 + 2*1 //第三次 = 2^3*T(n-3) + 1 + 2*1 + 2*2 //第n次 = 2^n*T(n-n) + 1 + 2^1 + 2^2 + 2^3 + ... + 2^(n-1) n不能为0，向前推一个 //第n-1次 = (2^(n-1)) * T(n-(n-1)) + 1 + 2^1 + 2^2 + 2^3 + ... + 2^(n-2) n不能为0，向前推一个 // = (2^(n-1)) * T(1) + 1 + 2^1 + 2^2 + 2^3 + ... + 2^(n-2) // = (2^(n-1)) * O(1) [+ 1 + 2^1 + 2^2 + 2^3 + ... + 2^(n-2)]后面阶比n-1小忽略不计 = … = (2^(n-1))*T(1)+1+2^1+2^2+…+2^(n-2) = 2^(n-1) = O(2^n) "},"page/1044.html":{"url":"page/1044.html","title":"空间复杂度","keywords":"","body":"空间复杂度 概述 　　一个算法的存储量包括形参所占空间和临时变量所占空间。在对算法进行存储空间分析时，只考察临时变量所占空间。 　　算法的空间复杂度定义为:S(n) = O(g(n))，表示随着问题规模 n 的增大，算法运行所需存储量的增长率与 g(n) 的增长率相同。 　　空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的量度，一般也作为问题规模n的函数，以数量级形式给出，记作：S(n)=O(g(n))、Ω(g(n))或Θ(g(n))，其中渐进符号的含义与时间复杂度中的含义相同。 　　注意：若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的辅助变量所占额外空间。若所需额外空间相对于输入数据量来说是常数，则称此算法为原地工作。若所需存储量依赖于特定的输入，则通常按最坏情况考虑。引用相当于给个变量别名，不占用空间。 为什么算法占用的空间只考虑临时空间，而不必考虑形参的空间呢？这是因为形参的空间会在调用该算法的算法中考虑，例如，以下maxfun算法调用max算法： void maxfun() { int b[]={1,2,3,4,5},n=5; 　　printf(\"Max=%d\\n\",max(b,n)); } int max(int a[]，int n) { int i，maxi=0; for (i=1;ia[maxi]) maxi=i; return a[maxi]; } maxfun算法中为b数组分配了相应的内存空间，其空间复杂度为O(n)，如果在max算法中再考虑形参a的空间，这样重复计算了占用的空间。 算法的存储量包括: 1．输入数据所占空间 2．程序本身所占空间 3．辅助变量所占空间 int max(int a[]，int n) { int i，maxi=0; for (i=1;ia[maxi]) maxi=i; return a[maxi]; } 函数体内分配的变量空间为临时空间，不计形参占用的空间， 这里的仅计i、maxi变量的空间，其空间复杂度为O(1)。 分析算法的空间复杂度。　　 void func(int n) { int i=1,k=100; while (i 有如下递归算法，分析调用 maxelem(a，0，n-1) 的空间复杂度。 int maxelem(int a[],int i,int j) { int mid=(i+j)/2,max1,max2; if (imax2)?max1:max2; } else return a[i]; } 解：执行该递归算法需要多次调用自身，每次调用只临时分配3个整型变量的空间（O(1)）。 设调用maxelem(a，0，n-1)的空间为S(n)，有： S(n)=O(1) 当n=1 S(n)=2S(n/2)+O(1) 当n>1 o(1)是int mid=(i+j)/2,max1,max2;常量空间 //2S(n/2)前面的2是因为分两半递归，后面的S(n/2)表示每一半递归的空间复杂度，里面的n/2表示，每一半只递归一半的数 则： S(n) = 2S(n/2)+1 = 2[2S(n/(2^2))+1]+1 = 2^2*S(n/(2^2)+2*1+1 = 2^3*S(n/(2^3))+1+2^1+2^2 = … = 2^k*S(n/(2^k))+1+2^1+2^2+…+2^(k-1) //（设n=2^k，即k=log_2^n） = 2^k + (1-2^k)/(1-2) = 2^k - 1 + 2^k = 2*n -1 = O(n) = 2^(log_2^n)* S(1) + 1 + 2^1 + 2^2 + ... + 2^(log_2^n -1) = n*O(1) + 1 + 2^1 + 2^2 + ... + n - 1 = 2n-1 = O(n) 等比公式： Sn=a(1−rn)1−r S_n=\\frac{a(1-r^n)}{1-r} S​n​​=​1−r​​a(1−r​n​​)​​ 其中a为首项，r为公比，r不为1 等差公式： 其中a为首项，d为公差 "},"page/1046.html":{"url":"page/1046.html","title":"算法设计","keywords":"","body":"算法设计 算法设计是一件非常困难的工作,通常设计一个“好”的算法应考虑多个目标,包括正确性、可读性、健壮性和高效性等。 算法设计的原则 设计算法时，通常应考虑达到的目标（判断好坏的标准） 1.正确性 　　首先，算法应当满足以特定的“规格说明”方式给出的需求。其次，对算法是否“正确”的理解可以有以下四个层次：a．程序中不含语法错误；b．程序对于几组输入数据能够得出满足要求的结果；c．程序对于精心选择的、典型、苛刻且带有刁难性的几组输入数据能够得出满足要求的结果；d．程序对于一切合法的输入数据都能得出满足要求的结果；通常以第 c 层意义的正确性作为衡量一个算法是否合格的标准。 2. 可读性 　　算法主要是为了人的阅读与交流，其次才是为计算机执行，因此算法应该易于人的理解；另一方面，晦涩难读的程序易于隐藏较多错误而难以调试。 3. 健壮性 　　当输入的数据非法时，算法应当恰当地作出反映或进行相应处理，而不是产生莫名奇妙的输出结果。并且，处理出错的方法不应是中断程序的执行，而应是返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。 4. 高效率与低存储量需求 　　通常，效率指的是算法执行时间；存储量指的是算法执行过程中所需的最大存储空间，两者都与问题的规模有关。 5.可使用性 ​ 要求算法能够很方便地使用，这个特性也叫用户友好性。 算法设计基本步骤 算法设计技术 存在多种算法设计技术(也称为算法设计策略),它们是设计算法的一般性方法。已经证明这些技术对于设计好的算法非常有用,在掌握了这些技术之后,设计新的和有用的算法会变得容易。 经常采用的算法设计技术主要有分治法、动态规划法、贪心法、回溯法、分支限界法、概率算法和近似算法等。另外,在解决计算机领域以外的问题时,这些技术也能起到很好的指导作用。 由于实际问题各种各样,问题求解的方法千变万化,所以算法设计又是一个灵活的充满智慧的过程,需要设计人员根据实际情况具体问题具体分析。 "},"page/1045.html":{"url":"page/1045.html","title":"设计工具STL","keywords":"","body":"1.概述 1.1定义 ​ STL主要由container（容器）、algorithm（算法）和iterator（迭代器）三大部分构成，容器用于存放数据对象（元素），算法用于操作容器中的数据对象。 1.2stl容器 一个STL容器就是一种数据结构，如链表、栈和队列等，这些数据结构在STL中都已经实现好了，在算法设计中可以直接使用它们。 数据结构 说 明 实现头文件 向量（vector） 连续存储元素。底层数据结构为数组，支持快速随机访问 字符串（string） 字符串处理容器 双端队列（deque） 连续存储的指向不同元素的指针所组成的数组。底层数据结构为一个中央控制器和多个缓冲区，支持首尾元素（中间不能）快速增删，也支持随机访问 链表（list） 由结点组成的链表，每个结点包含着一个元素。底层数据结构为双向链表，支持结点的快速增删 栈（stack） 后进先出的序列。底层一般用deque（默认）或者list实现 队列（queue） 先进先出的序列。底层一般用deque（默认）或者list实现 优先队列（priority_queue） 元素的进出队顺序由某个谓词或者关系函数决定的一种队列。底层数据结构一般为vector（默认）或者deque 集合（set）/多重集合（multiset） 由结点组成的红黑树，每个结点都包含着一个元素，set中所有元素有序但不重复，multiset中所有关键字有序但不重复 映射（map）/多重映射（multimap） 由（关键字，值）对组成的集合，底层数据结构为红黑树，map中所有关键字有序但不重复，multimap中所有关键字有序但可以重复 为此，使用STL时必须将下面的语句插入到源代码文件开头： ​ using namespace std; 这样直接把程序代码定位到std命名空间中。 1.3STL算法 ​ STL算法是用来操作容器中数据的模板函数，STL提供了大约100个实现算法的模版函数。例如，STL用sort()来对一个vector中的数据（通用数据）进行排序，用find()来搜索一个list中的对象。 ​ STL算法部分主要由头文件、和组成。 例如，以下程序使用STL算法sort()实现整型数组a的递增排序： #include using namespace std; void main() { int a[]={2,5,4,1,3}; sort(a,a+5); for (int i=0;i1.4stl迭代器 指针的另一个说法 ​ STL迭代器用于访问容器中的数据对象。 ​ 每个容器都有自己的迭代器，只有容器自己才知道如何访问自己的元素。 ​ 迭代器像C/C++中的指针，算法通过迭代器来定位和操作容器中的元素。 （整型指针只能指整型，向量指向量） 常用的迭代器有： iterator：指向容器中存放元素的迭代器，用于正向遍历容器中的元素。 const_iterator：指向容器中存放元素的常量迭代器，只能读取容器中的元素。 reverse_iterator：指向容器中存放元素的反向迭代器，用于反向遍历容器中的元素。 const_reverse_iterator：指向容器中存放元素的常量反向迭代器，只能读取容器中的元素。 迭代器的常用运算如下： ++：正向移动迭代器。 --：反向移动迭代器。 *：返回迭代器所指的元素值。 vector myv; //即将定义一个整型变量 myv.push_back(1); //push_back尾部插入 myv.push_back(2); myv.push_back(3); //向量的定义和变量的插入 vector::iterator it; //定义正向迭代器it for (it=myv.begin();it!=myv.end();++it) //从头到尾遍历所有元素 myv.end()最后一个元素的后面 printf(\"%d \",*it); //输出：1 2 3 printf(\"\\n\"); vector::reverse_iterator rit; //定义反向迭代器rit for (rit=myv.rbegin();rit!=myv.rend();++rit) //从尾到头遍历所有元素 myv.rend()第一个元素的前面 printf(\"%d \",*rit); //输出：3 2 1 printf(\"\\n\"); "},"page/1041.html":{"url":"page/1041.html","title":"常用的STL容器","keywords":"","body":"2.常用的STL容器 顺序容器 适配器容器 关联容器 2.1顺序容器 2.1.1 vector（向量容器） 1.定义 它是一个向量类模板。向量容器相当于数组。 用于存储具有相同数据类型的一组元素，可以从末尾快速的插入与删除元素，快速地随机访问元素，但是在序列中间插入、删除元素较慢，因为需要移动插入或删除处后面的所有元素。 定义vector容器的几种方式如下： vector v1; //定义元素为int的向量v1 相当于动态数组 vector v2(10); //指定向量v2的初始大小为10个int元素 vector v3(10，1.23); //指定v3的10个初始元素的初值为1.23 vector v4(a，a+5); //用数组a[0..4]共5个元素初始化v4 2.成员函数 vector提供了一系列的成员函数，vector主要的成员函数如下： empty()：判断当前向量容器是否为空。 size()：返回当前向量容器的中的实际元素个数。 []：返回指定下标的元素。 reserve(n)：为当前向量容器预分配n个元素的存储空间。 capacity()：返回当前向量容器在重新进行内存分配以前所能容纳的元素个数。 resize(n) ：调整当前向量容器的大小，使其能容纳n个元素。 push_back()：在当前向量容器尾部添加了一个元素。 insert(pos，elem)：在pos位置插入元素elem，即将元素elem插入到迭代器pos指定元素之前。 front()：获取当前向量容器的第一个元素。 back()：获取当前向量容器的最后一个元素。 erase()：删除当前向量容器中某个迭代器或者迭代器区间指定的元素。 clear()：删除当前向量容器中所有元素。 迭代器函数： begin()：返回指向容器第一个元素的迭代器 end()：返回指向容器最后元素（后面）的迭代器 rbegin()：倒数 rend()：倒数 调用方法：变量点函数 #include using namespace std; void main() { vector myv; //定义vector容器myv vector::iterator it; //定义myv的正向迭代器it myv.push_back(1); //在myv末尾添加元素1 it=myv.begin(); //it迭代器指向开头元素1 myv.insert(it,2); //在it指向的元素之前插入元素2 myv.push_back(3); //在myv末尾添加元素3 myv.push_back(4); //在myv末尾添加元素4 it=myv.end(); //it迭代器指向尾元素4的后面 it--; //it迭代器指向尾元素4 myv.erase(it); //删除元素4 for (it=myv.begin();it!=myv.end();++it) printf(\"%d \",*it); printf(\"\\n\"); }//结果213 2.1.2string（字符串容器） 1.定义 string是一个保存字符序列的容器，所有元素为字符类型，类似vector。 除了有字符串的一些常用操作以外，还有包含了所有的序列容器的操作。字符串的常用操作包括增加、删除、修改、查找比较、连接、输入、输出等。 创建string容器的几种方式如下： char cstr[]=\"China! Greate Wall\"; //C-字符串 string s1(cstr); // s1:China! Greate Wall string s2(s1); // s2:China! Greate Wall string s3(cstr，7，11); // s3:Greate Wall string s4(cstr，6); // s4:China! string s5(5，'A'); // s5:AAAAA 2.常用的成员函数如下 empty()：判断当前字符串是否为空串。 size()：返回当前字符串的实际字符个数（返回结果为size_type类型）。 length()：返回当前字符串的实际字符个数。 [idx]：返回当前字符串位于idx位置的字符，idx从0开始。 at(idx)：返回当前字符串位于idx位置的字符。 compare(const string& str)：返回当前字符串与字符串str的比较结果。在比较时，若两者相等，返回0；前者小于后者，返回-1；否则返回1。 append(cstr)：在当前字符串的末尾添加一个字符串str。 insert(size_type idx，const string& str) ：在当前字符串的idx处插入一个字符串str。 empty()：判断当前字符串是否为空串。 size()：返回当前字符串的实际字符个数（返回结果为size_type类型）。 length()：返回当前字符串的实际字符个数。 [idx]：返回当前字符串位于idx位置的字符，idx从0开始。 at(idx)：返回当前字符串位于idx位置的字符。 compare(const string& str)：返回当前字符串与字符串str的比较结果。在比较时，若两者相等，返回0；前者小于后者，返回-1；否则返回1。 append(cstr)：在当前字符串的末尾添加一个字符串str。 insert(size_type idx，const string& str) ：在当前字符串的idx处插入一个字符串str。 迭代器函数：begin()、end()、rbegin()最后一个元素后面、rend()第一个函数前面。 #include #include using namespace std; void main() { string s1=\"\",s2,s3=\"Bye\"; s1.append(\"Good morning\"); //s1=\" Good morning\" s2=s1; //s1=\" Good morning\" int i=s2.find(\"morning\"); //i=5 查找i位置 s2.replace(i,s2.length()-i,s3); //相当于s2.replace(5,7,s3) cout 求解模板生成工具问题。成成最近在搭建一个网站，其中一些页面的部分内容来自数据库中不同的数据记录，但是页面的基本结构是相同的。例如，对于展示用户信息的页面，当用户为Tom时，网页的源代码如下： 而当用户为Jerry时，网页的源代码如下： 这样的例子在包含动态内容的网站中还有很多。为了简化生成网页的工作，成成觉得他需要引入一套模板生成系统。模板是包含特殊标记的文本。成成用到的模板只包含一种特殊标记，格式为，其中VAR是一个变量。该标记在模板生成时会被变量VAR的值所替代。例如，如果变量name = \"Tom\"，则{{ name }}会生成Tom。具体的规则如下： 变量名由大小写字母、数字和下划线（_）构成，且第一个字符不是数字，长度不超过16个字符。 变量名是大小写敏感的，Name和name是两个不同的变量。 变量的值是字符串。 如果标记中的变量没有定义，则生成空串，相当于把标记从模板中删除。 模板不递归生成。也就是说，如果变量的值中包含形如{{ VAR }}的内容，不再做进一步的替换。 输入格式：输入的第一行包含两个整数m和n，分别表示模板的行数和模板生成时给出的变量个数。接下来m行，每行是一个字符串，表示模板。接下来n行，每行表示一个变量和它的值，中间用一个空格分隔。值是字符串，用双引号（\"）括起来，内容可包含除双引号以外的任意可打印 ASCII 字符（ASCII码范围32, 33, 35～126）。 输出格式：输出包含若干行，表示模板生成的结果。 样例输入： 11 2 User {{ name }} {{ name }} Email: {{ email }} Address: {{ address }} name \"David Beckham\" email \"david@beckham.com\" 样例输出： User David Beckham David Beckham Email: david@beckham.com Address: 评测用例规模与约定： 0≤m≤100，0≤n≤100 输入的模板每行长度不超过80个字符（不包含换行符）。 输入保证模板中所有以 {{开始的子串都是合法的标记，开始是两个左大括号和一个空格，然后是变量名，结尾是一个空格和两个右大括号。 输入中所有变量的值字符串长度不超过 100 个字符（不包括双引号）。 保证输入的所有变量的名字各不相同。 解：采用vector向量content存放网页，每一行作为一个元素。用map容器存放转换字符串。例如，对于题目中的样例，content向量中下标为0到10的元素如下： User {{ name }} {{ name }} Email: {{ email }} Address: {{ address }} mymap映射容器中包含如下两个结点（注意双引号是值的一部分）： mymap[email]= \"david@beckham.com\" mymap[name]= \"David Beckham\" 然后扫描content的每个元素，查找形如“{{ var }}”的字符串，将{{ var }}用mymap[var]替换（注意替换部分不包含双引号），在一个元素中可以有多个需要替换的内容。例如，将： href=\"mailto:{{ email }}\">{{ email }} 替换为： href=\"mailto:david@beckham.com\">david@beckham.com 字符串查找、替换均采用string的成员函数完成。对应的程序如下： #include #include #include #include using namespace std; vector content; //存放网页 map mymap; //存放转换字符串 int m，n; void trans() //网页转换 { for(int i=0;i=0 && pos2>=0) //找到{{ }} { string var=content[i].substr(pos1+3，pos2-pos1-4); if(mymap.count(var)) //提取形如{{var}} { string result=mymap[var].substr(2， mymap[var].length()-3); content[i].replace(pos1，var.length()+6，result); //替换 } else content[i].replace(pos1，var.length()+6，\"\"); pos=pos1+var.length(); } else //没有找到{{ }}，pos指向当前字符串末尾 pos = content[i].length(); } while(pos> m >> n; cin.ignore(); //屏蔽回车键 for(i=0;i::value_type( line.substr(0，pos)，line.substr(pos))); } trans(); for (i=0;i 2.1.3deque（双端队列容器） 1.定义 它是一个双端队列类模板。双端队列容器由若干个块构成，每个块中元素地址是连续的，块之间的地址是不连续的，有一个特定的机制将这些块构成一个整体。可以从前面或后面快速插入与删除元素，并可以快速地随机访问元素，但删除元素较慢。 定义deque双端队列容器的几种方式如下： deque dq1; //定义元素为int的双端队列dq1 deque dq2(10); //指定dq2的初始大小为10个int元素 deque dq3(10，1.23); //指定dq3的10个初始元素的初值为1.23 deque dq4(dq2.begin()，dq2.end()); //用dq2的所有元素初始化dq4 2.deque主要的成员函数如下 empty()：判断双端队列容器是否为空队。 size()：返回双端队列容器中元素个数。 push_front(elem)：在队头插入元素elem。 push_back(elem)：在队尾插入元素elem。 pop_front()：删除队头一个元素。 pop_back()：删除队尾一个元素。 erase()：从双端队列容器中删除一个或几个元素。 clear()：删除双端队列容器中所有元素。 迭代器函数：begin()、end()、rbegin()、rend()。 #include using namespace std; void disp(deque &dq) //输出dq的所有元素 { deque::iterator iter; //定义迭代器iter for (iter=dq.begin();iter!=dq.end();iter++) printf(\"%d \",*iter); printf(\"\\n\"); } void main() { deque dq; //建立一个双端队列dq dq.push_front(1); //队头插入1 dq.push_back(2); //队尾插入2 dq.push_front(3); //队头插入3 dq.push_back(4); //队尾插入4 printf(\"dq: \"); disp(dq); dq.pop_front(); //删除队头元素 dq.pop_back(); //删除队尾元素 printf(\"dq: \"); disp(dq); }//3124//12 2.1.4list（链表容器） 1.定义 它是一个双链表类模板。可以从任何地方快速插入与删除。它的每个结点之间通过指针链接，不能随机访问元素。 定义list容器的几种方式如下： list l1; //定义元素为int的链表l1 list l2 (10); //指定链表l2的初始大小为10个int元素 list l3 (10，1.23); //指定l3的10个初始元素的初值为1.23 list l4(a，a+5); //用数组a[0..4]共5个元素初始化l4 2.list的主要成员函数如下 empty()：判断链表容器是否为空。 size()：返回链表容器中实际元素个数。 push_back()：在链表尾部插入元素。 pop_back()：删除链表容器的最后一个元素。 remove ()：删除链表容器中所有指定值的元素。 remove_if(cmp)：删除链表容器中满足条件的元素。 erase()：从链表容器中删除一个或几个元素。 unique()：删除链表容器中相邻的重复元素。 clear()：删除链表容器中所有的元素。 insert(pos，elem)：在pos位置插入元素elem，即将元素elem插入到迭代器pos指定元素之前。 insert(pos，n，elem)：在pos位置前插入n个元素elem。 insert(pos，pos1，pos2)：在迭代器pos处插入[pos1，pos2)的元素。 reverse()：反转链表。 sort()：对链表容器中的元素排序。 迭代器函数：begin()、end()、rbegin()、rend()。 说明：STL提供的sort()排序算法主要用于支持随机访问的容器，而list容器不支持随机访问，为此，list容器提供了sort()采用函数用于元素排序。类似的还有unique()、reverse()、merge()等STL算法。 #include using namespace std; void disp(list &lst) //输出lst的所有元素 { list::iterator it; for (it=lst.begin();it!=lst.end();it++) printf(\"%d \",*it); printf(\"\\n\"); } void main() { list lst; //定义list容器lst list::iterator it,start,end; lst.push_back(5); //添加5个整数5,2,4,1,3 lst.push_back(2); lst.push_back(4); lst.push_back(1); lst.push_back(3); printf(\"初始lst: \"); disp(lst); it=lst.begin(); //it指向首元素5 start=++lst.begin(); //start指向第2个元素2 end=--lst.end(); //end指向尾元素3 lst.insert(it,start,end); printf(\"执行lst.insert(it,start,end)\\n\"); printf(\"插入后lst: \"); disp(lst); } 2.2关联容器 2.2.1set（集合容器）/ multiset（多重集容器） 1.定义 set和multiset都是集合类模板，其元素值称为关键字。set中元素的关键字是唯一的，multiset中元素的关键字可以不唯一，而且默认情况下会对元素按关键字自动进行升序排列。 查找速度比较快，同时支持集合的交、差和并等一些集合上的运算，如果需要集合中的元素允许重复那么可以使用multiset。 2.set/multiset的成员函数如下 empty()：判断容器是否为空。 size()：返回容器中实际元素个数。 insert()：插入元素。 erase()：从容器删除一个或几个元素。 clear()：删除所有元素。 count(k)：返回容器中关键字k出现的次数。 find(k)：如果容器中存在关键字为k的元素，返回该元素的迭代器，否则返回end()值。 upper_bound()：返回一个迭代器，指向关键字大于k的第一个元素。 lower_bound()：返回一个迭代器，指向关键字不小于k的第一个元素。 迭代器函数：begin()、end()、rbegin()、rend()。 #include using namespace std; void main() { set s; //定义set容器s set::iterator it; //定义set容器迭代器it s.insert(1); s.insert(3); s.insert(2); s.insert(4); s.insert(2); printf(\" s: \"); for (it=s.begin();it!=s.end();it++) printf(\"%d \",*it); printf(\"\\n\"); //s:1 2 3 4 multiset ms; //定义multiset容器ms multiset::iterator mit; //定义multiset容器迭代器mit ms.insert(1); ms.insert(3); ms.insert(2); ms.insert(4); ms.insert(2); printf(\"ms: \"); for (mit=ms.begin();mit!=ms.end();mit++) printf(\"%d \",*mit); printf(\"\\n\"); } //ms:1 2 2 3 4 2.2.2map（映射容器）/ multimap（多重映射容器） 1.定义 类似于数组，关键字当成下标 map和multimap都是映射类模板。映射是实现关键字与值关系的存储结构，可以使用一个关键字key来访问相应的数据值value。 在set/multiset中的key和value都是key类型，而key和value是一个pair类结构。 pair类结构的声明形如： struct pair { T first; T second; } map/multimap利用pair的 2.map/multimap的主要成员函数如下 empty()：判断容器是否为空。 size()：返回容器中实际元素个数。 map[key]：返回关键字为key的元素的引用，如果不存在这样的关键字，则以key作为关键字插入一个元素（不适合multimap）。 insert(elem)：插入一个元素elem并返回该元素的位置。 clear()：删除所有元素。 find()：在容器中查找元素。 count()：容器中指定关键字的元素个数（map中只有1或者0）。 迭代器函数：begin()、end()、rbegin()、rend()。 在map中修改元素非常简单，这是因为map容器已经对[]运算符进行了重载（对其含义进行重新定义）。例如： map mymap; //定义map容器mymap，其元素类型为pair mymap['a'] = 1; //或者mymap.insert(pair('a',1) );//键字符型‘单引号’ 值int 获得map中一个值的最简单方法如下： int ans = mymap['a']; 只有当map中有这个关键字（'a'）时才会成功，否则会自动插入一个元素，值为初始化值。可以使用find() 方法来发现一个关键字是否存在。 #include using namespace std; void main() { map mymap; //定义map容器mymap mymap.insert(pair('a',1)); //插入方式1 mymap.insert(map::value_type('b',2)); //插入方式2 mymap['c']=3; //插入方式3 map::iterator it; for(it=mymap.begin();it!=mymap.end();it++) printf(\"[%c,%d] \",it->first,it->second); printf(\"\\n\"); } //[a,1] [b,2] [c,3] 2.3适配器容器 2.3.1stack（栈容器） 它是一个栈类模板，和数据结构中的栈一样，具有后进先出的特点。栈容器默认的底层容器是deque。也可以指定其他底层容器。 例如，以下语句指定myst栈的底层容器为vector： stack > myst; //第2个参数指定底层容器为vector stack容器主要的成员函数如下： empty()：判断栈容器是否为空。 size()：返回栈容器中实际元素个数。 push(elem)：元素elem进栈。 top()：返回栈顶元素。 pop()：元素出栈。 注意：stack容器没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。 #include using namespace std; void main() { stack st; st.push(1); st.push(2); st.push(3); printf(\"栈顶元素: %d\\n\",st.top()); printf(\"出栈顺序: \"); while (!st.empty()) //栈不空时出栈所有元素 { printf(\"%d \",st.top()); st.pop() ; } printf(\"\\n\"); } 2.3.2queue（队列容器） 它是一个队列类模板，和数据结构中的队列一样，具有先进先出的特点。不允许顺序遍历，没有begin()/end()和rbegin()/rend()这样的用于迭代器的成员函数。 主要的成员函数如下： empty()：判断队列容器是否为空。 size()：返回队列容器中实际元素个数。 front()：返回队头元素。 back()：返回队尾元素。 push(elem)：元素elem进队。 pop()：元素出队。 #include using namespace std; void main() { queue qu; qu.push(1); qu.push(2); qu.push(3); printf(\"队头元素: %d\\n\",qu.front()); printf(\"队尾元素: %d\\n\",qu.back()); printf(\"出队顺序: \"); while (!qu.empty()) //出队所有元素 { printf(\"%d \",qu.front()); qu.pop(); } printf(\"\\n\"); } 2.3.3priority_queue（优先队列容器） 它是一个优先队列类模板。优先队列是一种具有受限访问操作的存储结构，元素可以以任意顺序进入优先队列。 一旦元素在优先队列容器中，出队操作将出队列最高优先级元素。 主要的成员函数如下： empty()：判断优先队列容器是否为空。 size()：返回优先队列容器中实际元素个数。 push(elem)：元素elem进队。 top()：获取队头元素。 pop()：元素出队。 #include using namespace std; void main() { priority_queue qu; qu.push(3); qu.push(1); qu.push(2); printf(\"队头元素: %d\\n\",qu.top()); printf(\"出队顺序: \"); while (!qu.empty()) //出队所有元素 { printf(\"%d \",qu.top()); qu.pop(); } printf(\"\\n\"); } "},"page/1040.html":{"url":"page/1040.html","title":"STL在算法设计中的应用","keywords":"","body":"3.STL在算法设计中的应用 3.1存放主数据 算法设计重要步骤是设计数据的存储结构，除非特别指定，程序员可以采用STL中的容器存放主数据，选择何种容器不仅要考虑数据的类型，还有考虑数据的处理过程。 例如，字符串可以采用string或者vector来存储，链表可以采用list来存储。 【例1.11】有一段英文由若干单词组成，单词之间用一个空格分隔。编写程序提取其中的所有单词。 解：这里的主数据是一段英文，采用string字符串str存储它，最后提取的单词采用vector容器words存储。 #include #include #include using namespace std; void solve(string str,vector &words) //产生所有单词words { string w; int i=0; int j=str.find(\" \"); //查找第一个空格 while (j!=-1) //找到单词后循环 { w=str.substr(i,j-i); //提取一个单词，从i到j-i在str里面取 words.push_back(w); //单词添加到words中 i=j+1; j=str.find(\" \",i); //查找下一个空格 } if (i void main() { string str=\"The following code computes the intersection of two arrays\"; vector words; solve(str,words); cout ::iterator it; for (it=words.begin();it!=words.end();++it) cout 3.2存放临时数据 在算法设计中，有时需要存放一些临时数据。通常的情况是，如果后存入的元素先处理，可以使用stack栈容器； 如果先存入的元素先处理，可以使用queue队列容器；如果元素处理顺序按某个优先级进行，可以使用priority_queue优先队列容器。 【例1.12】设计一个算法，判断一个含有()、[]、{}三种类型括号的表达式中所有括号是否匹配。 解：这里的主数据是一个字符串表达式，采用string字符串str存储它。在判断括号是否匹配时需要用到一个栈（因为每个右括号都是和前面最近的左括号匹配），采用stack容器作为栈。 #include #include #include using namespace std; bool solve(string str) //判断str中括号是否匹配 { stack st; int i=0; while (i 3.3检测数据元素的唯一性 可以使用map容器或者哈希表容器检测数据元素是否唯一或者存放累计个数。 【例1.13】设计一个算法判断字符串str中每个字符是否唯一。如，\"abc\"的每个字符是唯一的，算法返回true，而\"accb\"的中字符'c'不是唯一的，算法返回false。 解：设计map容器mymap，第一个分量key的类型为char，第二个分量value的类型为int，表示对应关键字出现的次数。 将字符串str中每个字符作为关键字插入到map容器中，插入后对应出现次数增1。如果某个字符的出现次数大于1，表示不唯一，返回false；如果所有字符唯一，返回true。 bool isUnique(string &str) //检测str中的所有字符是否唯一的 { map mymap; for (int i=0;i1) 　　return false; } return true; } 求多少对相反数。有N个非零且各不相同的整数。请你编一个程序求出它们中有多少对相反数（a和-a为一对相反数）。时间限制为1.0s，内存限制：256.0MB。 输入格式：第一行包含一个正整数 N（1≤N≤500）。第二行为N个用单个空格隔开的非零整数，每个数的绝对值不超过1000，保证这些整数各不相同。 输出格式：只输出一个整数，即这N个数中包含多少对相反数。 样例输入： 5 1 2 3 -1 -2 样例输出： 2 解：可以直接采用暴力思路求解，但可能超时。 这里使用STL的map容器mymap（其实用哈希表效率更高），对于输入的负整数x，将（-x，1）插入。扫描所有输入的正整数y，当mymap[y]存在时说明对应一个相反数对，ans增1。 #include #include using namespace std; #define MAX 505 int main() { int ans=0; //累计相反数对的个数 int n，x，i; int a[MAX]; map mymap; scanf(\"%d\"，&n); for (i=0;i(-x，1)); } for (i=0;i0 && mymap[a[i]]) ans++; printf(\"%d\\n\"，ans); } 3.4数据排序 对于list容器的元素排序可以使用其成员函数sort()，对于数组或者vector等具有随机访问特性的容器，可以使用STL算法sort()。 下面以STL算法sort()为例讨论。 1）内置数据类型的排序 对于内置数据类型的数据，sort()默认是以less（小于关系函数）作为关系函数实现递增排序。 为了实现递减排序，需要调用头文件中定义的greater类模板。 例如，以下程序使用greater()实现vector容器元素的递减排序（其中sort(myv.begin(),myv.end(),less())语句等同于sort(myv.begin(),myv.end())，实现默认的递增排序）： #include #include #include #include //包含less、greater等 using namespace std; void Disp(vector &myv) //输出vector的元素 { vector::iterator it; for(it = myv.begin();it!=myv.end();it++) cout myv(a,a+n); cout ()); cout ()); cout 2）自定义数据类型的排序 对于自定义数据类型如结构体数据，同样默认是less（即小于关系函数）作为关系函数，但需要重载该函数。另外还可以自己定义关系函数()。在这些重载函数或者关系函数中指定数据的排序顺序（按哪些结构体成员排序，是递增还是递减）。 归纳起来，实现排序时主要有两种方式： 方式1：在声明结构体类型中重载 #include #include #include #include using namespace std; struct Stud { int no; string name; Stud(int no1,string name1) //构造函数 { no=no1; name=name1; } bool operator则按no递增排序 } }; struct Cmp //方式2：定义关系函数() { bool operator()(const Stud &s,const Stud &t) const { return s.name则按name递减排序 } }; void Disp(vector &myv) //输出vector的元素 { vector::iterator it; for(it = myv.begin();it!=myv.end();it++) cout no name myv(a,a+n); cout 3.5优先队列作为堆 在有些算法设计中用到堆，堆采用STL的优先队列来实现，优先级的高低由队列中数据元素的关系函数（比较运算符）确定，很多情况下需要重载关系函数。 1）元素为内置数据类型的堆 对于C/C++内置数据类型，默认是less（小于关系函数）作为关系函数，值越大优先级的越高（即大根堆），可以改为以greater作为关系函数，这样值越大优先级的越低（即小根堆）。 例如，以下程序中pq1为大根堆（默认），pq2为小根堆（通过greater实现）： #include #include using namespace std; void main() { int a[]={3,6,1,5,4,2}; int n=sizeof(a)/sizeof(a[0]); //(1)优先级队列pq1默认是使用vector作容器 priority_queue pq1(a,a+n); cout ,greater > pq2(a,a+n); cout 2）元素为自定义类型的堆 对于自定义数据类型如结构体数据，同样默认是less（即小于关系函数）作为关系函数，但需要重载该函数。 另外还可以自己定义关系函数()。在这些重载函数或者关系函数中指定数据的优先级（优先级取决于哪些结构体，是越大越优先还是越小越优先）。 #include #include #include using namespace std; struct Stud //声明结构体Stud { int no; string name; Stud(int n,string na) //构造函数 { no=n; name=na; } bool operator(const Stud &s) const //重载>关系函数 { return no>s.no; } }; //结构体的关系函数,改写operator() struct StudCmp { bool operator()(const Stud &s,const Stud &t) const { return s.name pq1(a,a+n); cout 关系函数定义pq2 priority_queue,greater > pq2(a,a+n); cout ,StudCmp > pq3(a,a+n); cout "},"page/1047.html":{"url":"page/1047.html","title":"算法结构","keywords":"","body":"算法结构 从算法的结构上看,算法可以分为非递归形式和递归形式。其中非递归算法的时间复杂度分析较简单。 "},"page/1048.html":{"url":"page/1048.html","title":"递归形式","keywords":"","body":"递归 "},"page/1049.html":{"url":"page/1049.html","title":"定义","keywords":"","body":"定义 递归是指子程序(或函数)直接调用自己或通过一系列调用语句间接调用自己,是一种描述问题和解决问题的常用方法。 在计算机算法设计与分析中,递归技术是十分有用的。使用递归技术往往使函数的定义和算法的描述简洁且易于理解。还有一些问题,虽然其本身并没有明显的递归结构,但用递归技术来求解使设计出的算法简洁易懂且易于分析,为此在介绍其他算法设计方法之前先讨论它。 递归有两个基本要素:边界条件,即确定递归到何时终止,也称为递归出口;递归模式,即大问题是如何分解为小问题的,也称为递归体。 "},"page/1050.html":{"url":"page/1050.html","title":"场景","keywords":"","body":"场景 "},"page/1051.html":{"url":"page/1051.html","title":"原理","keywords":"","body":"原理 "},"page/1052.html":{"url":"page/1052.html","title":"递归模型","keywords":"","body":"递归模型 "},"page/1053.html":{"url":"page/1053.html","title":"执行过程","keywords":"","body":"执行过程 "},"page/1054.html":{"url":"page/1054.html","title":"递归转化","keywords":"","body":"递归转化 "},"page/1055.html":{"url":"page/1055.html","title":"步骤","keywords":"","body":"步骤 "},"page/1056.html":{"url":"page/1056.html","title":"比较","keywords":"","body":"比较 时间复杂度 (1)展开法。 将递归式中等式右边的项根据递归式进行替换,称为展开。展开后的项被再次展开,如此下去,直到得到一个求和表达式,得到结果。 (2)代换法。 这一名称来源于当归纳假设用较小值时,用所猜测的值代替函数的解。在用代换法解递归式时需要3个步骤:猜测解的形式;用数学归纳法证明猜测的正确性;求出使解真正有效的常数。 尽管代换法提供了一种证明递归式解的正确性的简单方法,但并不存在通用的方法来猜测递归式的正确解,这种猜测需要经验,有时甚至是创造性的。由于往往很难得到“好”的猜测,因此这种方法较难用。 (3)递归树法。 递归树法弥补了代换法猜测困难的缺点,它适于提供“好”的猜测,然后用代换法证明。在递归树中,每一个结点都代表递归函数调用集合中一个子问题的代价。将树中每一层内结点的代价相加得到一个每层代价的集合,再将每层的代价相加得到递归式所有层的总代价。当用递归式表示分治算法的时间复杂度时,递归树方法尤其有用。 (4)主方法。 主方法也称为主定理,给出了求解以下形式的递归式的快速方法。 T(n)=aT(n/b)+f(n) T(n)=aT(n/b)+f(n) T(n)=aT(n/b)+f(n) 其中, $a \\ge 1$ 和$b>1$是常数,$f(n)$是一个渐进的正函数。 "},"page/1057.html":{"url":"page/1057.html","title":"实例","keywords":"","body":"实例 "},"page/1058.html":{"url":"page/1058.html","title":"拓展","keywords":"","body":"拓展 "},"page/1059.html":{"url":"page/1059.html","title":"数学归纳法","keywords":"","body":"数学归纳法 "},"page/1060.html":{"url":"page/1060.html","title":"递推式计算","keywords":"","body":"递推式计算 "},"page/1061.html":{"url":"page/1061.html","title":"非递归形式","keywords":"","body":"循环 "},"page/1062.html":{"url":"page/1062.html","title":"定义","keywords":"","body":"定义 "},"page/1063.html":{"url":"page/1063.html","title":"场景","keywords":"","body":"场景 "},"page/1064.html":{"url":"page/1064.html","title":"原理","keywords":"","body":"原理 "},"page/1065.html":{"url":"page/1065.html","title":"步骤","keywords":"","body":"步骤 "},"page/1066.html":{"url":"page/1066.html","title":"比较","keywords":"","body":"比较 "},"page/1067.html":{"url":"page/1067.html","title":"实例","keywords":"","body":"实例 "},"page/1068.html":{"url":"page/1068.html","title":"拓展","keywords":"","body":"拓展 "},"page/1069.html":{"url":"page/1069.html","title":"解决思想","keywords":"","body":"解决思想 "},"page/1080.html":{"url":"page/1080.html","title":"蛮力法","keywords":"","body":"蛮力法 "},"page/1081.html":{"url":"page/1081.html","title":"定义","keywords":"","body":"定义 　　蛮力法，也称穷举法、枚举法，是一种简单直接地解决问题的方法，通常直接基于问题的描述和所涉及的概念定义，找出所有可能的解。然后选择其中的一种或多种解，若该解不可行则试探下一种可能的解。 "},"page/1082.html":{"url":"page/1082.html","title":"场景","keywords":"","body":"场景 搜索所有的解空间：问题的解存在于规模不大的解空间中。 搜索所有的路径：这类问题中不同的路径对应不同的解。 直接计算：按照基于问题的描述和所涉及的概念定义，直接进行计算。往往是一些简单的题，不需要算法技巧的。 模拟和仿真：按照求解问题的要求直接模拟或仿真即可。 "},"page/1083.html":{"url":"page/1083.html","title":"原理","keywords":"","body":"原理 "},"page/1084.html":{"url":"page/1084.html","title":"一般格式","keywords":"","body":"一般格式 直接采用蛮力法的一般格式 　　在直接采用蛮力法设计算法中，主要是使用循环语句和选择语句，循环语句用于穷举所有可能的情况，而选择语句判定当前的条件是否为所求的解。 基本格式 for (循环变量x取所有可能的值) //循环 { ┇ if (x满足指定的条件)//判断 输出x;//解 ┇ } "},"page/1085.html":{"url":"page/1085.html","title":"步骤","keywords":"","body":"步骤 实现角度： 采用基本的穷举思路，直接采用穷举计算法 穷举中应用递归，递归搜索解空间 "},"page/1086.html":{"url":"page/1086.html","title":"比较","keywords":"","body":"比较 "},"page/1087.html":{"url":"page/1087.html","title":"实例","keywords":"","body":"实例 "},"page/1088.html":{"url":"page/1088.html","title":"拓展","keywords":"","body":"拓展 "},"page/1089.html":{"url":"page/1089.html","title":"递归应用","keywords":"","body":"递归应用 "},"page/1070.html":{"url":"page/1070.html","title":"分治法","keywords":"","body":"分治法 分治与递归就像一对孪生兄弟,经常同时应用于算法设计之中,并由此产生许多高效的算法。 我们知道,任何一个可以用计算机求解的问题所需要的计算时间都与其规模有关。问题的规模越小,解题所需要的计算时间往往越少,从而较容易处理。 例如,对于n个元素的排序问题,当 n = 1 时,不需要任何比较;当 n =2时,只要做一次比较即可;......而当n较大时,问题 就不那么容易处理了。 要想直接解决一个较大的问题,有时是相当困难的:分治法的设计思想是将一个难以直接解决的大问题分解成一些规模较小的相同问题,以便各个击破,分而治之。 如果规模为n的问题可分解成k个子问题,$1 一般来说,分治算法在每一层递归上都有3个步骤。 (1) 分解。将原问题分解成一系列子问题。 (2) 求解。递归地求解各子问题。若子问题足够小,则直接求解。 (3) 合并。将子问题的解合并成原问题的解。 "},"page/1071.html":{"url":"page/1071.html","title":"定义","keywords":"","body":"定义 "},"page/1072.html":{"url":"page/1072.html","title":"场景","keywords":"","body":"场景 "},"page/1073.html":{"url":"page/1073.html","title":"原理","keywords":"","body":"原理 "},"page/1074.html":{"url":"page/1074.html","title":"设计思想","keywords":"","body":"设计思想 "},"page/1075.html":{"url":"page/1075.html","title":"步骤","keywords":"","body":"步骤 "},"page/1076.html":{"url":"page/1076.html","title":"比较","keywords":"","body":"比较 "},"page/1077.html":{"url":"page/1077.html","title":"实例","keywords":"","body":"实例 "},"page/1078.html":{"url":"page/1078.html","title":"拓展","keywords":"","body":"拓展 "},"page/1079.html":{"url":"page/1079.html","title":"并行性计算","keywords":"","body":"并行性计算 "},"page/1090.html":{"url":"page/1090.html","title":"解空间","keywords":"","body":"解空间 "},"page/1091.html":{"url":"page/1091.html","title":"回溯法--满足条件所有解","keywords":"","body":"回溯法 在确定了解空间的组织结构后,回溯法从开始结点(根结点)出发,以深度优先的方式搜索整个解空间。这个开始结点就成为一个活结点,同时也成为当前的扩展结点。在当前的扩展结点处,搜索向纵深方向移至一个新结点。这个新结点就成为一个新的活结点,并成为当前扩展结点。如果在当前扩展结点处不能再向纵深方向移动,则当前的扩展结点就成为死结点。换句话说,这个结点不再是一个活结点。此时,应往回移动(回溯)至最近的一个活结点处,并使这个活结点成为当前的扩展结点。回溯法即以这种工作方式递归地在解空间中搜索,直到找到所要求的解或解空间中已无活结点时为止。 运用回溯法解题通常包含以下3个步骤。 (1) 针对所给问题,定义问题的解空间。 (2) 确定易于搜索的解空间结构。 (3) 以深度优先的方式搜索解空间。 回溯法的算法框架有非递归和递归两种方式。 问题的解空间往往很大,为了有效地进行搜索,需要在搜索的过程中对某些结点进行剪枝,而对哪些结点进行剪枝,需要设计限界函数来判断。因此,限界函数的设计是回溯法的一个核心问题,也是一个很难的问题。设计限界函数的通用的指导原则是尽可能多和尽可能早地“杀掉”不可能产生最优解的活结点。好的限界函数可以大大减少问题的搜索空间,从而大大提高算法的效率。 "},"page/1092.html":{"url":"page/1092.html","title":"定义","keywords":"","body":"定义 "},"page/1093.html":{"url":"page/1093.html","title":"场景","keywords":"","body":"场景 "},"page/1094.html":{"url":"page/1094.html","title":"原理","keywords":"","body":"原理 "},"page/1095.html":{"url":"page/1095.html","title":"算法框架","keywords":"","body":"算法框架 "},"page/1096.html":{"url":"page/1096.html","title":"步骤","keywords":"","body":"步骤 "},"page/1097.html":{"url":"page/1097.html","title":"比较","keywords":"","body":"比较 "},"page/1098.html":{"url":"page/1098.html","title":"时间分析","keywords":"","body":"时间分析 "},"page/1099.html":{"url":"page/1099.html","title":"实例","keywords":"","body":"实例 "},"page/1100.html":{"url":"page/1100.html","title":"拓展","keywords":"","body":"拓展 "},"page/1101.html":{"url":"page/1101.html","title":"深度优先遍历异同","keywords":"","body":"深度优先遍历异同 "},"page/1102.html":{"url":"page/1102.html","title":"分枝限界法--满足条件一个解","keywords":"","body":"分枝限界法 分支限界法类似于回溯法,也是一种在问题的解空间树T上搜索问题解的算法。 但在一般情况下,分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解,而分支限界法的求解目标是找出满足约束条件的一个解,或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解,即在某种意义下的最优解。 由于求解目标不同,导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T,而分支限界法以广度优先或以最小耗费优先的方式搜索解空间树T。分支限界法的搜索策略是每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点,就一次性产生其所有儿子结点。在这些儿子结点中,那些导致不可行解或非最优解的儿子结点被舍弃,其余儿子结点被加入活结点表中。此后,从活结点表中取下一结点成 为当前扩展结点,并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。人们已经利用分支限界法解决了大量离散最优化的实际问题。 与回溯法相似,限界函数的设计是分支限界法的一个核心问题,也是一个很难的问题。如何设计限界函数来有效地减小搜索空间是应用分支限界法要考虑的问题。 据从活结点表中选择下一扩展结点的不同方式,可将分支限界法分为几种不同的类型。最常用的有以下两种。 (1) 队列式(FIFO,先进先出)分支限界法。队列式分支限界法将活结点表组织成一个队列,并按队列的先进先出原则选择下一个结点作为扩展结点。 (2) 优先队列式分支限界法。优先队列式分支限界法将活结点表组织成一个优先队列,并按优先队列中规定的结点优先级选取优先级最高的下一个结点作为扩展结点。 优先队列中规定的结点优先级通常用一个与该结点相关的数值P来表示。结点优先级的高低与P值的大小相关。最大优先队列规定值较大的结点优先级较髙。在算法实现时,通常用一个最大堆来实现最大优先队列,用最大堆的Deletemax操作抽取堆中下一个结点成为当前扩展结点。类似地,最小优先队列规定^值较小的结点优先级较髙。在算法实现时,常用一个最小堆来实现最小优先队列,用最小堆的Deletemin操作抽取堆中下一个结点成为当前扩展结点。 "},"page/1103.html":{"url":"page/1103.html","title":"定义","keywords":"","body":"定义 "},"page/1104.html":{"url":"page/1104.html","title":"场景","keywords":"","body":"场景 "},"page/1105.html":{"url":"page/1105.html","title":"原理","keywords":"","body":"原理 "},"page/1106.html":{"url":"page/1106.html","title":"设计思想","keywords":"","body":"设计思想 "},"page/1107.html":{"url":"page/1107.html","title":"步骤","keywords":"","body":"步骤 "},"page/1108.html":{"url":"page/1108.html","title":"比较","keywords":"","body":"比较 "},"page/1109.html":{"url":"page/1109.html","title":"时间性能","keywords":"","body":"时间性能 "},"page/1110.html":{"url":"page/1110.html","title":"实例","keywords":"","body":"实例 "},"page/1111.html":{"url":"page/1111.html","title":"拓展","keywords":"","body":"拓展 "},"page/1112.html":{"url":"page/1112.html","title":"贪心法--局部最优","keywords":"","body":"贪心法 作为一种算法设计技术,贪心法是一种简单的方法。和动态规划法一样,贪心法也经常用于解决最优化问题。 与动态规划法不同的是,贪心法在解决问题的策略上是仅根据当前己有的信息做出选择,而且一旦做出了选择,不管将来有什么结果,这个选择都不会改变。换而言之,贪心法并不是从整体最优考虑,它所做出的选择只是在某种意义上的局部最优。这种局部最优选择并不能保证总能获得全局最优解,但通常能得到较好的近似最优解。 举一个简单的贪心法例子,平时购物找钱时,为使找回的零钱的硬币数最少,从最大面值的币种开始,按递减的顺序考虑各币种,先尽量用大面值的币种,当不足大面值币种的金额时才去考虑下一种较小面值的币种,这就是在釆用贪心法.这种方法在这里总是最优,是因为银行对其发行的硬币种类和硬币面值的巧妙安排。如果只有面值分别为1、5和11单位的硬币,而希望找回总额为15单位的硬币,按贪心算法,应找1个11单位面值的硬币和4个1单位面值的硬币,共找回5个硬币。但最优的解答应是3个5单位面值的硬币。 我们知道,贪心算法并不总能得到最优解,那么对于一个具体的问题,如何得知是否可以用贪心法来求解以及能否得到问题的最优解呢?这个问题很难得到肯定的回答。但是,从许多可以用贪心法求得最优解的问题中看到,这类问题一般具有两个重要的性质。 (1) 最优子结构。当一个问题的最优解包含其子问题的最优解时,称此问题具有最优子结构。问题具有最优子结构是该问题可以采用动态规划法或者贪心法求解的关键性质。 (2) 贪心选择性质。指问题的整体最优解可以通过一系列局部最优的选择,即贪心选择来得到。这是贪心法和动态规划法的主要区别。证明一个问题具有贪心选择性质也是贪心法的一个难点。 "},"page/1113.html":{"url":"page/1113.html","title":"定义","keywords":"","body":"定义 "},"page/1114.html":{"url":"page/1114.html","title":"场景","keywords":"","body":"场景 "},"page/1115.html":{"url":"page/1115.html","title":"原理","keywords":"","body":"原理 "},"page/1116.html":{"url":"page/1116.html","title":"步骤","keywords":"","body":"步骤 "},"page/1117.html":{"url":"page/1117.html","title":"比较","keywords":"","body":"比较 "},"page/1118.html":{"url":"page/1118.html","title":"实例","keywords":"","body":"实例 "},"page/1119.html":{"url":"page/1119.html","title":"拓展","keywords":"","body":"拓展 "},"page/1121.html":{"url":"page/1121.html","title":"动态规划--全局最优","keywords":"","body":"动态规划 动态规划算法与分治法类似,其基本思想也是将待求解问题分解成若干个子问题,先求解子问题,然后从这些子问题的解得到原问题的解。与分治法不同的是,适合用动态规划法求解的问题,经分解得到的子问题往往不是独立的。若用分治法来解这类问题,则相同的子问题会被求解多次,以至于最后解决原问题需要耗费指数级时间。然而,不同子问题的数目常常只有多项式量级。如果能够保存已解决的子问题的答案,在需要时再找出已求得的答案,这样就可以避免大量的重复计算,从而得到多项式时间的算法。为了达到这个目的,可以用一个表来记录所有已解决的子问题的答案。不管该子问题以后是否被用到,只要它被计算过,就将其结果填入表中。这就是动态规划法的基本思路。 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中,可能会有许多可行解,每个解都对应于一个值,我们希望找到具有最优值(最大值或最小值)的那个解。当然,最优解可能会有多个,动态规划算法能找出其中的一个最优解。设计一个动态规划算法,通常按照以下几个步骤进行。 (1) 找出最优解的性质,并刻画其结构特征。 (2) 递归地定义最优解的值。 (3) 以自底向上的方式计算出最优值。 (4) 根据计算最优值时得到的信息,构造一个最优解。 步骤(1) 〜 (3)是动态规划算法的基本步骤。在只需要求出最优值的情形下,步骤(4)可以省略。若需要求出问题的一个最优解,则必须执行步骤(4)。此时,在步骤(3)中计算最优值时,通常需记录更多的信息,以便在步骤(4)中根据所记录的信息快速构造出一个最优解。 动态规划法是一个非常有效的算法设计技术,那么何时可以应用动态规划来设计算法呢? 对于一个给定的问题,若其具有以下两个性质,可以考虑用动态规划法来求解。 (1) 最优子结构。如果一个问题的最优解中包含了其子问题的最优解,就说该问题具有最优子结构。当一个问题具有最优子结构时,提示我们动态规划法可能会适用,但是此时贪心策略可能也是适用的。 (2) 重叠子问题。重叠子问题指用来解原问题的递归算法可反复地解同样的子问题,而不是总在产生新的子问题。即当一个递归算法不断地调用同一个问题时,就说该问题包含重叠子问题。此时若用分治法递归求解,则每次遇到子问题都会视为新问题,会极大地降低算法的效率,而动态规划法总是充分利用重叠子问题,对每个子问题仅计算一次,把解保存在一个在需要时就可以查看的表中,而每次查表的时间为常数。 "},"page/1122.html":{"url":"page/1122.html","title":"定义","keywords":"","body":"定义 "},"page/1123.html":{"url":"page/1123.html","title":"场景","keywords":"","body":"场景 "},"page/1124.html":{"url":"page/1124.html","title":"原理","keywords":"","body":"原理 "},"page/1125.html":{"url":"page/1125.html","title":"步骤","keywords":"","body":"步骤 "},"page/1126.html":{"url":"page/1126.html","title":"比较","keywords":"","body":"比较 "},"page/1127.html":{"url":"page/1127.html","title":"实例","keywords":"","body":"实例 "},"page/1128.html":{"url":"page/1128.html","title":"拓展","keywords":"","body":"拓展 "},"page/1130.html":{"url":"page/1130.html","title":"应用模块类","keywords":"","body":"应用类 "},"page/1131.html":{"url":"page/1131.html","title":"查找","keywords":"","body":"查找 "},"page/1132.html":{"url":"page/1132.html","title":"基于数据结构","keywords":"","body":"基于数据结构 "},"page/1133.html":{"url":"page/1133.html","title":"顺序表查找","keywords":"","body":"顺序表查找 "},"page/1134.html":{"url":"page/1134.html","title":"有序表查找","keywords":"","body":"有序表查找 "},"page/1135.html":{"url":"page/1135.html","title":"二分法查找","keywords":"","body":"二分法查找 "},"page/1136.html":{"url":"page/1136.html","title":"插值查找","keywords":"","body":"插值查找 "},"page/1137.html":{"url":"page/1137.html","title":"斐波那契查找","keywords":"","body":"斐波那契查找 "},"page/1138.html":{"url":"page/1138.html","title":"线性索引查找","keywords":"","body":"线性索引查找 "},"page/1139.html":{"url":"page/1139.html","title":"稠密索引","keywords":"","body":"稠密索引 "},"page/1140.html":{"url":"page/1140.html","title":"分块索引","keywords":"","body":"分块索引 "},"page/1141.html":{"url":"page/1141.html","title":"倒排索引","keywords":"","body":"倒排索引 "},"page/1142.html":{"url":"page/1142.html","title":"树表查找","keywords":"","body":"树表查找 "},"page/1143.html":{"url":"page/1143.html","title":"二叉树查找","keywords":"","body":"二叉树查找 "},"page/1144.html":{"url":"page/1144.html","title":"平衡查找树","keywords":"","body":"平衡查找树 "},"page/1145.html":{"url":"page/1145.html","title":"平衡二叉树(AVL)","keywords":"","body":"平衡二叉树(AVL) "},"page/1146.html":{"url":"page/1146.html","title":"红黑树","keywords":"","body":"红黑树 "},"page/1147.html":{"url":"page/1147.html","title":"多路查找树","keywords":"","body":"多路查找树 "},"page/1148.html":{"url":"page/1148.html","title":"2-3树","keywords":"","body":"2-3树 "},"page/1149.html":{"url":"page/1149.html","title":"2-3-4树","keywords":"","body":"2-3-4树 "},"page/1150.html":{"url":"page/1150.html","title":"B树","keywords":"","body":"B树 "},"page/1151.html":{"url":"page/1151.html","title":"B+树","keywords":"","body":"B+树 "},"page/1152.html":{"url":"page/1152.html","title":"散列表查找","keywords":"","body":"散列表查找 "},"page/1153.html":{"url":"page/1153.html","title":"散列函数","keywords":"","body":"散列函数 "},"page/1154.html":{"url":"page/1154.html","title":"冲突处理","keywords":"","body":"冲突处理 "},"page/1161.html":{"url":"page/1161.html","title":"排序","keywords":"","body":"排序 "},"page/1162.html":{"url":"page/1162.html","title":"插入排序","keywords":"","body":"插入排序 "},"page/1163.html":{"url":"page/1163.html","title":"直接插入排序","keywords":"","body":"直接插入排序 "},"page/1164.html":{"url":"page/1164.html","title":"希尔排序","keywords":"","body":"希尔排序 "},"page/1165.html":{"url":"page/1165.html","title":"选择排序","keywords":"","body":"选择排序 "},"page/1166.html":{"url":"page/1166.html","title":"简单选择排序","keywords":"","body":"简单选择排序 "},"page/1167.html":{"url":"page/1167.html","title":"堆排序","keywords":"","body":"堆排序 "},"page/1168.html":{"url":"page/1168.html","title":"交换排序","keywords":"","body":"交换排序 "},"page/1169.html":{"url":"page/1169.html","title":"冒泡排序","keywords":"","body":"冒泡排序 "},"page/1170.html":{"url":"page/1170.html","title":"快速排序","keywords":"","body":"快速排序 "},"page/1171.html":{"url":"page/1171.html","title":"归并排序","keywords":"","body":"归并排序 "},"page/1172.html":{"url":"page/1172.html","title":"桶排序","keywords":"","body":"桶排序 "},"page/1173.html":{"url":"page/1173.html","title":"计数排序","keywords":"","body":"计数排序 "},"page/1174.html":{"url":"page/1174.html","title":"基数排序","keywords":"","body":"基数排序 "},"page/1184.html":{"url":"page/1184.html","title":"组合","keywords":"","body":"组合 "},"page/1175.html":{"url":"page/1175.html","title":"数学基础类","keywords":"","body":"数学类 "},"page/1176.html":{"url":"page/1176.html","title":"高数","keywords":"","body":"高数 "},"page/1177.html":{"url":"page/1177.html","title":"几何","keywords":"","body":"几何 "},"page/1157.html":{"url":"page/1157.html","title":"向量","keywords":"","body":"计算复杂性 "},"page/1178.html":{"url":"page/1178.html","title":"线代","keywords":"","body":"线代 "},"page/1179.html":{"url":"page/1179.html","title":"矩阵","keywords":"","body":"矩阵 "},"page/1180.html":{"url":"page/1180.html","title":"概率与近似","keywords":"","body":"概率与近似 "},"page/1155.html":{"url":"page/1155.html","title":"概论算法","keywords":"","body":"概论算法 前面讨论的算法对于所有合理的输入都给出正确的输出,概率算法将这一条件放宽,把随机性的选择加入到算法中。 在算法执行某些步骤时,可以随机地选择下一步该如何进行,同时允许结果以较小的概率出现错误,并以此为代价,获得算法运行时间的大幅度减少。 概率算法的一个基本特征是对所求解问题的同一实例用同一概率算法求解两次,可能得到完全不同的效果。这两次求解所需的时间甚至所得到的结果可能会有相当大的差别。如果一个问题没有有效的确定性算法可以在一个合理的时间内给出解,但是该问题能接受小概率错误,那么采用概率算法就可以快速找到这个问题的解。 一般情况下,概率算法具有以下基本特征。 (1) 概率算法的输入包括两部分,一部分是原问题的输入,另一部分是一个供算法进行随机选择的随机数序列。 (2) 概率算法在运行过程中,包括一处或多处随机选择,根据随机值来决定算法的运行路径。 (3) 概率算法的结果不能保证一定是正确的,但能限制其出错概率。 (4) 概率算法在不同的运行过程中,对于相同的输入实例可以有不同的结果,因此,对于相同的输入实例,概率算法的执行时间可能不同。 概率算法大致分为4类:数值概率算法、蒙特卡罗 (Monte Carlo )算法、拉斯维加斯 (LasVegas )算法和舍伍德( Sherwood )算法。 (1) 数值概率算法。数值概率算法常用于数值问题的求解。这类算法得到的往往是近似解,且近似解的精度随计算时间的增加不断提高。在多数情况下,要计算出问题的精确解是不可能的或者是没有必要的,因此用数值概率算法可得到相当满意的解。 (2) 蒙特卡罗算法。蒙特卡罗算法用于求问题的精确解。用蒙特卡罗算法能求得问题的一个解,但这个解未必是正确的。求得正确解的概率依赖于算法所用的时间,算法所用的时间越多,得到正确解的概率就越高。蒙特卡罗算法的主要缺点也在于此,一般情况下,无法有效地判定所得到的解是否肯定正确。 (3) 拉斯维加斯算法。拉斯维加斯算法不会得到不正确的解。一旦用拉斯维加斯算法找到一个解,这个解就一定是正确解。拉斯维加斯算法找到正确解的概率随它所用的计算时间的增加而提高。对于所求解问题的任一实例,用同一拉斯维加斯算法反复对该实例求解足够多次,可使求解失效的概率任意小。 (4) 舍伍德算法。舍伍德算法总能求得问题的一个解,且所求得的解总是正确的。当一个确定性算法在最坏情况下的计算复杂度与其在平均情况下的计算复杂度有较大差别时,可在这个确定性算法中引入随机性将它改造成一个舍伍德算法,消除或减少问题的好坏实例间的这种差别。舍伍德算法的精髓不是避免算法的最坏情况行为,而是设法消除这种最坏情形行为与特定实例之间的关联性。 "},"page/1156.html":{"url":"page/1156.html","title":"近似算法","keywords":"","body":"近似算法 迄今为止,所有的难解问题都没有多项式时间算法,釆用回溯法和分支限界法等算法设计技术可以相对有效地解决这类问题。然而,这些算法的时间性能常常是无法保证的。近似算法是解决难解问题的一种有效策略,其基本思想是放弃求最优解,而用近似最优解代替最优解,以换取算法设计上的简化和时间复杂度的降低。近似算法是这样一个过程:虽然它可能找不到一个最优解,但它总会给待求解的问题提供一个解。为了具有实用性,近似算法必须能够给出算法所产生的解与最优解之间的差别或者比例的一个界限,它保证任意一个实例的近似最优解与最优解之间相差的程度。显然,这个差别越小,近似算法越具有实用性。 衡量近似算法性能最重要的标准有以下两个。 (1) 算法的时间复杂度。近似算法的时间复杂度必须是多项式阶的,这是近似算法的基本目标。 (2) 解的近似程度。近似最优解的近似程度也是设计近似算法的重要目标。近似程度与近似算法本身、问题规模,乃至不同的输入实例有关。 "},"page/1181.html":{"url":"page/1181.html","title":"离散","keywords":"","body":"离散 "},"page/1182.html":{"url":"page/1182.html","title":"数论","keywords":"","body":"数论 "},"page/1120.html":{"url":"page/1120.html","title":"生产应用类","keywords":"","body":"阶段决策 "},"page/1186.html":{"url":"page/1186.html","title":"数据挖掘","keywords":"","body":"数据挖掘 1.数据挖掘概述 在当今的大数据时代,数据挖掘、机器学习和人工智能这些名词在我们的生活、工作和学习中已经是耳熟能详的词汇。我们需要各种技术来分析爆炸式增长的各类数据,以发现隐含在这些数据中的有价值的信息和知识。作为一门交叉学科,数据挖掘利用机器学习方法对多种数据,包括数据库数据、数据仓库数据、 Web 数据等进行分析和挖掘。数据挖掘的核心是算法,其主要功能包括分类、回归、关联规则和聚类等。 2.分类 分类是一种有监督的学习过程,根据历史数据预测未来数据的模型。分类的数据对象属性分为两类,一般属性和分类属性或者目标属性。对数据分类有两个步骤:学习模型和应用模型,在分类过程中,涉及到的数据包括训练数据集、测试数据集和未知数据。学习模型是指基于训练数据集釆用分类算法建立学习模型。而应用模型是指应用测试数据集的数据到学习模型中,根据输出来评估模型的好坏以及将未知数据输入到学习模型中,预测数据的类型。 存在多种分类算法。决策树归纳是一种自顶向下的递归树算法,使用一种属性选择度量为树的每个非叶子节点选择待分裂的属性。 ID 3、 C 4.5和 CART 是典型的决策树算法,它们使用不同的属性选择度量。朴素贝叶斯算法和贝叶斯信念网络基于后验概率的贝叶斯公式进行分类,前者假设类条件独立,即数据对象的各个属性之间互相独立,后者考虑属性之间的关系。后向传播( BP )算法是使用梯度下降法的神经网络方法。它搜索一组权重,对数据建模,使得数据对象的预测类型和实际类型之间的平均平方距离最小。支持向量机( SVM )是一种用于线性和非线性数据的分类算法。它把输入数据变换到较高维空间,使用称作支持向量的基本元组,从中发现分离数据的超平面。 可以用混淆矩阵来评估分类模型的质量。如对于两类问题,混淆矩阵给出真正例 (True Positive )、真负例 (True Negative )、假正例 (False Positive )、假负例 (False Negative )。基于这些量可以计算分类模型的准确率、灵敏度(召回率)、特效性、精度、 F 度量等。可以用显著性检验和 ROC 曲线来评价不同分类模型的好坏。把己知类别的数据集分为训练集和测试集时,可以釆用保持、随机抽样、交叉检验和自助法。而可以将多个分类模型组合起来以提高分类的质量,其中袋装、提升和随机森林是典型的组合分类方法。 3.频繁模式和关联规则挖掘 挖掘海量数据中的频繁模式和关联规则可以有效地指导企业发现交叉销售机会、进行决策分析和商务管理等。一个典型的应用是购物篮分析,即顾客经常购买的商品集合,从而分析顾客的购买习惯。而其中,沃尔玛公司对其顾客购买数据进行分析时,发现购买尿布的客户通常也会购买啤酒,根据这一规律,他们在摆放货架时,有意的把啤酒和尿布放到一起,以便顾客购买。这就是有名的啤酒尿布故事。频繁模式时频繁出现在数据集中的模式,要求满足最小支持度阈值,如啤酒和尿布频繁的出现在同一购物篮中。关联规则是形如 A 4 B 的规则,其中 A和 B 表示数据集中的子集,要求 AB 既要满足最小支持度阈值,还要满足最小置信度阈值。如同时购买啤酒和尿布的购物篮满足最小支持度阈值,同时 A 4 B 满足最小置信度阈值。支持度和置信度的定义如下: $Support ( A -> B ) = P ( AUB )$ $Confidence ( A -> B ) = P ( B | A )$ 求解关联规则首先要求出数据集中的频繁模式,然后由频繁模式产生关联规则。人们提出了多种关联规则挖掘算法:类 Apriori 算法;基于频繁模式增长的方法,如FP - growth ;使用垂直数据格式的算法,如 ECLAT 。 4.聚类 聚类是一种无监督学习过程。根据数据的特征,将相似的数据对象归为一类,不相似的数据对象归到不同的类中,这就是聚类,每个聚类也称为簇。“物以类聚,人以群分”就是聚类的典型描述。 聚类的典型算法有:基于划分的方法、基于层次的方法、基于密度的方法、基于网格的方法和基于统计模型的方法。基于划分的方法将《个数据对象划分为灸个不相交的集合,每个集合称为一个簇。典型的算法有^均值、^中心点算法等。基于层次的方法将数据对象集进行层次的分解。根据其是自底向上还是自顶向下分解,可以分为凝聚的方法和分裂的方法,而前者的典型算法是 AGNES ,后者的典型算法是 DIANA 。基于密度的方法基于数据对象的邻域来进 行聚类分析,因此可以识别各种形状的簇,以及一个数据对象可以属于多个不同的簇,DBSCAN 、 OPTICS 和DENCLUE 是其中的典型算法。基于网格的方法把对象空间量化为有限个单元,形成一个网格结构。所有的聚类操作在该网格上进行, STING 和 CLIQUE 是其中的两个算法。基于统计模型的算法将数据对象集看作多个服从不同分布的数据集构成,聚类的目的是识别出这些不同的分布的数据对象, EM 算法是其中的一个典型算法。 5.数据挖掘的应用 数据挖掘在多个领域己有成功的应用。在银行和金融领域,可以进行贷款偿还预测和顾客信用政策分析、针对定向促销的顾客分类与聚类、洗黑钱和其他金融犯罪侦破等;在零售和电信业,可以进行促销活动的效果分析、顾客忠诚度分析、交叉销售分析、商品推荐、欺骗分析等。 "},"page/1187.html":{"url":"page/1187.html","title":"交叉学科类","keywords":"","body":"交叉学科--智能优化类 "},"page/1188.html":{"url":"page/1188.html","title":"仿生类","keywords":"","body":"仿生类 "},"page/1189.html":{"url":"page/1189.html","title":"人工神经网络","keywords":"","body":"人工神经网络 "},"page/1190.html":{"url":"page/1190.html","title":"遗传算法","keywords":"","body":"遗传算法 "},"page/1191.html":{"url":"page/1191.html","title":"禁忌搜索算法","keywords":"","body":"禁忌搜索算法 "},"page/1192.html":{"url":"page/1192.html","title":"蚁群算法","keywords":"","body":"蚁群算法 "},"page/1193.html":{"url":"page/1193.html","title":"粒子群优化算法","keywords":"","body":"粒子群优化算法 "},"page/1194.html":{"url":"page/1194.html","title":"物理类","keywords":"","body":"物理类 "},"page/1195.html":{"url":"page/1195.html","title":"模拟退火算法","keywords":"","body":"模拟退火算法 "},"page/1158.html":{"url":"page/1158.html","title":"计算模型","keywords":"","body":"计算模型 "},"page/1159.html":{"url":"page/1159.html","title":"N类问题","keywords":"","body":"N类问题 "},"page/1160.html":{"url":"page/1160.html","title":"P类问题","keywords":"","body":"P类问题 "},"page/1183.html":{"url":"page/1183.html","title":"NPC问题","keywords":"","body":"NPC问题 "},"page/1129.html":{"url":"page/1129.html","title":"算法实例","keywords":"","body":"算法实例 "},"page/11201.html":{"url":"page/11201.html","title":"完全数-蛮力法","keywords":"","body":"实例 问题描述 　　编写一个程序，输出2～1000之间的所有完全数。所谓完全数，是指这样的数，该数的各因子（除该数本身外）之和正好等于该数本身，例如：　 　 6=1+2+3　　 28=1+2+4+7+14 分析 先考虑对于一个整数m，如何判断它是否为完全数。 从数学知识可知：一个数m的除该数本身外的所有因子都在1～m/2之间。（最小的1×本身，但是本身已经被排除，2×本身的一半即m/2,所以所有的因子都在1~m/2之间） 算法中要取得因子之和，只要在1～m/2之间找到所有整除m的数，将其累加起来即可。 如果累加和与m本身相等，则表示m是一个完全数，可以将m输出。 for (m=2;m #include int main() { int m, i, j; //m用于遍历1到1000，i用于遍历1到m/2,j用于记录对应m的因子 for (m = 2; m "},"page/11202.html":{"url":"page/11202.html","title":"象棋算式-蛮力法","keywords":"","body":"实例 "},"page/11203.html":{"url":"page/11203.html","title":"二分法查找","keywords":"","body":"二分法查找 1.综述 二分法检索(binary search)又称折半检索，二分法检索是一种效率较高的检索方法。 2.简介 2.1 基本思想 设数组中的元素从小到大有序地存放在数组(array)中， 首先将给定值key与数组中间位置上元素的关键码(key)比较， 如果相等，则检索成功; 否则，若key小，则在数组前半部分中继续进行二分法检索； 若key大，则在数组后半部分中继续进行二分法检索。 这样，经过一次比较就缩小一半的检索区间， 如此进行下去，直到检索成功或检索失败。 2.2 流程 在数组[7, 8, 9, 10, 12, 20, 30, 40, 50, 80, 100]中查询到10元素，过程如下： 2.3 代码 "},"page/11204.html":{"url":"page/11204.html","title":"冒泡排序","keywords":"","body":"冒泡排序 1 综述 冒泡排序是最常用的排序算法， 算法重复地走访过要排序的数列，一次比较两个元素， 如果他们的顺序错误就把他们交换过来，这样越大的元素会经由交换慢慢“浮”到数列的顶端。 2 简介 2.1 流程 1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。 在这一点，最后的元素应该会是最大的数。 3. 针对所有的元素重复以上的步骤，除了最后一个。 4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 2.2 代码 //java冒泡排序的基础算法 import java.util.Arrays; public class Test { public static void main(String[] args) { int[] values = { 3, 1, 6, 2, 9, 0, 7, 4, 5, 8 }; bubbleSort(values); System.out.println(Arrays.toString(values)); } public static void bubbleSort(int[] values) { int temp; for (int i = 0; i values[j + 1]) { temp = values[j]; values[j] = values[j + 1]; values[j + 1] = temp; } } } } } 3 优化 3.1 分析 1.整个数列分成两部分：前面是无序数列，后面是有序数列。 2.初始状态下，整个数列都是无序的，有序数列是空。 3.每一趟循环可以让无序数列中最大数排到最后，(也就是说有序数列的元素个数增加1)，也就是不用再去顾及有序序列。 4.每一趟循环都从数列的第一个元素开始进行比较，依次比较相邻的两个元素，比较到无序数列的末尾即可(而不是数列的末尾);如果前一个大于后一个，交换。 5.判断每一趟是否发生了数组元素的交换，如果没有发生，则说明此时数组已经有序，无需再进行后续趟数的比较了。此时可以中止比较。 3.2 代码 //java冒泡排序的优化算法 import java.util.Arrays; public class Test1 { public static void main(String[] args) { int[] values = { 3, 1, 6, 2, 9, 0, 7, 4, 5, 8 }; bubbleSort(values); System.out.println(Arrays.toString(values)); } public static void bubbleSort(int[] values) { int temp; int i; // 外层循环：n个元素排序，则至多需要n-1趟循环 for (i = 0; i values[j + 1]) { temp = values[j]; values[j] = values[j + 1]; values[j + 1] = temp; //本趟发生了交换，表明该数组在本趟处于无序状态，需要继续比较； flag = false; } } //根据标记量的值判断数组是否有序，如果有序，则退出；无序，则继续循环。 if (flag) { break; } } } } "},"page/11205.html":{"url":"page/11205.html","title":"判断句子单词","keywords":"","body":"判断句子单词个数 #include int main(){ char str[80]; int i=0,num=0,word=0; char c; while((str[i++]=getchar()) !='\\n'); /*while((str[i++]=getchar() !='\\n') ) 原来的括号位置错了*/ /* ( ) */ /*赋值运算优先级比比较的优先级低，先比较了*/ str[i]='\\0'; for(i=0;(c=str[i])!='\\0';i++){ printf(\"%c\\n\",c); if(c==' ') word=0; else if(word==0) { word=1; num++; } } printf(\"there are %d words in the line.\\n\",num); return 0; } 正确思路应该是 先输入字符 getchar()， 把输入字符存起来 str[i++]=getchar() 再判断它是不是回车结束结束 str[i++] !='\\n' 然后 遍历存储的字符串有几个空格就知道有几个单词了 但是要注意几点 连续的空格不能算，如果一个句子是 i空格空格am 中间有两个空格再根据空格算就不对了 "},"page/11206.html":{"url":"page/11206.html","title":"实例","keywords":"","body":"实例 "},"page/11207.html":{"url":"page/11207.html","title":"实例","keywords":"","body":"实例 "},"page/11208.html":{"url":"page/11208.html","title":"实例","keywords":"","body":"实例 "},"page/11209.html":{"url":"page/11209.html","title":"实例","keywords":"","body":"实例 "},"page/11210.html":{"url":"page/11210.html","title":"实例","keywords":"","body":"实例 "},"page/11211.html":{"url":"page/11211.html","title":"实例","keywords":"","body":"实例 "},"page/11212.html":{"url":"page/11212.html","title":"实例","keywords":"","body":"实例 "},"page/11213.html":{"url":"page/11213.html","title":"实例","keywords":"","body":"实例 "},"page/11214.html":{"url":"page/11214.html","title":"实例","keywords":"","body":"实例 "},"page/11215.html":{"url":"page/11215.html","title":"实例","keywords":"","body":"实例 "},"page/11216.html":{"url":"page/11216.html","title":"实例","keywords":"","body":"实例 "},"page/11217.html":{"url":"page/11217.html","title":"实例","keywords":"","body":"实例 "},"page/11218.html":{"url":"page/11218.html","title":"实例","keywords":"","body":"实例 "},"page/11219.html":{"url":"page/11219.html","title":"实例","keywords":"","body":"实例 "},"page/11220.html":{"url":"page/11220.html","title":"实例","keywords":"","body":"实例 "},"page/11221.html":{"url":"page/11221.html","title":"实例","keywords":"","body":"实例 "},"page/11222.html":{"url":"page/11222.html","title":"实例","keywords":"","body":"实例 "},"page/11223.html":{"url":"page/11223.html","title":"实例","keywords":"","body":"实例 "},"page/11224.html":{"url":"page/11224.html","title":"实例","keywords":"","body":"实例 "},"page/11225.html":{"url":"page/11225.html","title":"实例","keywords":"","body":"实例 "},"page/11226.html":{"url":"page/11226.html","title":"实例","keywords":"","body":"实例 "},"page/11227.html":{"url":"page/11227.html","title":"实例","keywords":"","body":"实例 "},"page/11228.html":{"url":"page/11228.html","title":"实例","keywords":"","body":"实例 "},"page/11229.html":{"url":"page/11229.html","title":"实例","keywords":"","body":"实例 "},"page/11230.html":{"url":"page/11230.html","title":"实例","keywords":"","body":"实例 "},"page/11231.html":{"url":"page/11231.html","title":"实例","keywords":"","body":"实例 "},"page/11232.html":{"url":"page/11232.html","title":"实例","keywords":"","body":"实例 "},"page/11233.html":{"url":"page/11233.html","title":"实例","keywords":"","body":"实例 "},"page/11234.html":{"url":"page/11234.html","title":"实例","keywords":"","body":"实例 "},"page/11235.html":{"url":"page/11235.html","title":"实例","keywords":"","body":"实例 "},"page/11236.html":{"url":"page/11236.html","title":"实例","keywords":"","body":"实例 "},"page/11237.html":{"url":"page/11237.html","title":"实例","keywords":"","body":"实例 "},"page/11238.html":{"url":"page/11238.html","title":"实例","keywords":"","body":"实例 "},"page/11239.html":{"url":"page/11239.html","title":"实例","keywords":"","body":"实例 "},"page/11240.html":{"url":"page/11240.html","title":"实例","keywords":"","body":"实例 "},"page/11241.html":{"url":"page/11241.html","title":"实例","keywords":"","body":"实例 "},"page/11242.html":{"url":"page/11242.html","title":"实例","keywords":"","body":"实例 "},"page/11243.html":{"url":"page/11243.html","title":"实例","keywords":"","body":"实例 "},"page/11244.html":{"url":"page/11244.html","title":"实例","keywords":"","body":"实例 "},"page/11245.html":{"url":"page/11245.html","title":"实例","keywords":"","body":"实例 "},"page/1999.html":{"url":"page/1999.html","title":"end-1196-11246","keywords":"","body":"end-1185-1101 "}}
# 比较

### 时间复杂度

#### (1)展开法。

将递归式中等式右边的项根据递归式进行替换,称为展开。展开后的项被再次展开,如此下去,直到得到一个求和表达式,得到结果。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191103202758.png)

#### (2)代换法。

这一名称来源于当归纳假设用较小值时,用所猜测的值代替函数的解。在用代换法解递归式时需要3个步骤:猜测解的形式;用数学归纳法证明猜测的正确性;求出使解真正有效的常数。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191103203029.png)

尽管代换法提供了一种证明递归式解的正确性的简单方法,但并不存在通用的方法来猜测递归式的正确解,这种猜测需要经验,有时甚至是创造性的。由于往往很难得到“好”的猜测,因此这种方法较难用。



#### (3)递归树法。

递归树法弥补了代换法猜测困难的缺点,它适于提供“好”的猜测,然后用代换法证明。在递归树中,每一个结点都代表递归函数调用集合中一个子问题的代价。将树中每一层内结点的代价相加得到一个每层代价的集合,再将每层的代价相加得到递归式所有层的总代价。当用递归式表示分治算法的时间复杂度时,递归树方法尤其有用。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191103203327.png)

#### (4)主方法。

主方法也称为主定理,给出了求解以下形式的递归式的快速方法。
$$
T(n)=aT(n/b)+f(n)
$$
其中, $a \ge 1$ 和$b>1$是常数,$f(n)$是一个渐进的正函数。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191103203705.png)

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191103203724.png)






















# 时间复杂度

由于时间复杂度与空间复杂度分别对算法占用的时间和空间资源进行分析,计算方法相似,且空间复杂度分析相对简单一些,因此下面主要讨论时间复杂度。算法的时间复杂度分析主要是分析算法的运行时间,即算法执行所需要的基本操作数。

不同规模的输入所需要的基本操作数是不相同的,例如用同一个排序算法排序100个数和排序10 000个数所需要的基本操作数是不相同的,因此考虑特定输入规模的算法的具体操作数既是不现实的也是不必要的。在算法分析中,可以建立以输入规模n为自变量的函数$T(n)$来表示算法的时间复杂度。

即使对于相同的输入规模,数据分布不相同也影响了算法执行路径的不同,因此所需要的执行时间也不同。根据不同的输入,将算法的时间复杂度分析分为3种情况。

(1) 最佳情况。使算法执行时间最少的输入。一般情况下,不进行算法在最佳情况下的时间复杂度分析。应用最佳情况分析的一个例子是已经证明基于比较的排序算法的时间复杂度下限为 $\Omega (nlgn)$那么就不需要白费力气去想方设法将该类算法改进为线性时间复杂度的算法。

(2) 最坏情况。使算法执行时间最多的输入。一般会进行算法在最坏时间复杂度的分析,因为最坏情况是在任何输入下运行时间的一个上限,它给我们提供一个保障,实际情况不会比这更糟糕。另外,对于某些算法来说,最坏情况还是相当频繁的。而且对于许多算法来说,平均情况通常与最坏情况下的时间复杂度一样。

(3) 平均情况。算法的平均运行时间,一般来说,这种情况很难分析。举个简单的例子,现要排序10个不同的整数,输入就有10!种不同的情况,平均情况的时间复杂度要考虑每一种输入及其该输入的概率。平均情况分析可以按以下3个步骤进行。

+ 1 将所有的输入按其执行时间分类。
+ 2 确定每类输入发生的概率。
+ 3 确定每类输入的执行时间。

下式给出了 一般算法在平均情况下的复杂度分析。
$$
T(n)= \sum_{i=1}^{m}p_i \times t_i
$$

其中,仍$p_i$表示第i类输入发生的概率; $t_i$表示第i类输入的执行时间,输入分为m类。



### 渐进符号



以输入规模n为自变量建立的时间复杂度实际上还是较复杂的,例如$an^2+bn+c$ ,不仅与输入规模有关,还与系数a、b、和c 有关。此时可以对该函数做进一步的抽象,仅考虑运行时间的增长率或称为增长的量级,如忽略上式中的低阶项和髙阶项的系数,仅考虑$n^2$。当输入规模大到只有与运行时间的增长量级有关时,就是在研究算法的渐进效率。也就是说,从极限角度看,只关心算法运行时间如何随着输入规模的无限增长而增长。下面简单介绍3种常用的标准方法来简化算法的渐进分析。

+ (1) $O$记号。定义为:

给定一个函数$g(n)$,$$O(g(n))=\{f(n): \exists 正常数c和n_0,使得对所有的n \ge n_0,有0 \le f(n) \le cg(n)\}$$

如图下图 ( a )所示。$O( g ( n ))$表示一个函数集合,往往用该记号给出一个算法运行时间的渐进上界。

- (2) $\Omega$记号。定义为:

给定一个函数$g(n)$,$$\Omega(g(n))=\{f(n): \exists 正常数c和n_0,使得对所有的n \ge n_0,有0 \le cg(n) \le f(n)\}$$

如图下图 ( b )所示。$\Omega( g ( n ))$表示一个函数集合,往往用该记号给出一个算法运行时间的渐进下界。

- (3) $\Theta$记号。定义为:

给定一个函数$g(n)$,$$\Theta(g(n))=\{f(n): \exists 正常数c_1、c_2和n_0,使得对所有的n \ge n_0,有0 \le c_1g(n) \le f(n)\}$$

如图下图 ( a )所示。$\Theta( g ( n ))$表示一个函数集合,往往用该记号给出一个算法运行时间的渐进上界和渐进下届，即渐进紧致界。

![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191103195939.png)

<center>记号的用例图</center>

由上述定义可知，$f(n)=\Theta(g(n))$当且仅当$f(n)=O(g(n))和f(n)=\Omega(g(n))$



![](https://raw.githubusercontent.com/ZanderZhao/images/master/img2019/20191103201737.png)





























